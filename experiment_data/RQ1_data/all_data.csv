,Script,Descrizione,tempo_completamento,tool_used
0,1,"Inizializza il tempo attuale, ritorna la lista dei file nella direcotry data e lancia un eccezione se la directory è invalida o non accessibile. Input = File, Formatter, boolean, output = void. Utilizza un ciclo per visualizzare tutti i file. Se c'è una subdir chiama la funzione in maniera ricorsiva. Se il file è più grande del tempo settato lo cancella",03:30:00,True
1,2,"Conversione di un array di interi o float a boolean, input = null, output = boolean[], Utilizza uno switch per distinguere i vari casi di intero e float.",7.41.54,False
2,3,"Restituisce la cache del file passato in input, input = FileFactory, Object, DatasetUrl, buffer_size, CancelTask, spiObject, output = FileCachable. Utilizza librerie come Tracker per rintracciare i file nel filesystem attraverso la location fornita.",6.27.70,False
3,4,"Converte la stringa di comando in vari flag boolean e opzioni, aggiornando possibilmente la locazione del dataset, se richiesto. Input = NetcdFIle, String, Wirter, CancelTask, output = boolean. Come un parser utilizza una serie di if per effettuare la scelta corretta",4.47.75,True
4,2,"Lo script in questione riguarda una funzione ""acquire"", dove lo scopo ultimo è quello di stabilire se un file presente all'interno di una location è utile per esser inserito in cache. Nel caso in cui il file risulta vuoto viene incrementato l'attributo miss del tracker ""t"", atrimenti viene incrementato l'attributo hit del tracher ""t"".-> in output la funzioen restituisce il file aggiunto in cache.",06:25:00,False
5,3,"Lo script in questione riguarda una funzione ""print"", la quale prende in input un file, un comando e un writer per l'output e restituisce in output un valore booleano. In pratica la funzione prende il comando dato in input, lo divide in tanti piccoli token in base agli spazi nella riga di comando e tramite una serie di if, analizza ogni singolo token per poter settare una serie di variabili definite all'inizio della funzione. Inoltre viene posta maggiore attenzione nel caso in cui nel comando ci sia il nome di un dataset. In quel caso la funzione si salva quell'informazione se è presente nel comando, andando anche a modificare se serve la location del file in input tramite funzioni setLocation e getLocation in base al nome del dataset nella linea di comando. --> In output restituisce una variabile booleana ok. ",4.07.00,False
6,0,"Lo script tiene traccia del tempo, crea una lista del contenuto della directory e se risulta invalida e inaccessibile solleva un eccezione. Se una directory risulta vuota o abbastanza vecchia la prova ad eliminare o stampa il risultato. Processa il contenuto della directory ricorsivamente. Nel caso di subdirectory richiama ricorsivamente per arrivare alla root, nel caso dei file invece cancell quelli che superano il threshold settato e stampa il risultato. ",3.31.02,True
7,1,"Lo script inizializza un array per poi cambiargli il tipo. Successivamente con un switch case, vengono gestiti gli array di Int8, Int16, Int32, Int64 e per ognuno di questi converte ogni valore in un booleano. Successivamente farà la stessa cosa nel caso di array di Float32 e Float64. Infine solleva un eccezione nel caso in cui viene dato in pasto un tipo di array non supportato.",2.15.03,True
8,2.java,"Lo switch esamina il tipo di byte presente nell'array e verifica se sia un intero di 8,16,31,64 o un float di 32,64 byte. In base alla quantità di byte, verrà istanziato un array di byte, short, int, long, float, double dove verrà inserito il valore della variabile array. Istanziamo array di booleani ""retval"" di lunghezza dell`array data, scorriamo tutto l'array ed assegniamo a retval[i] il valore di data[i] se maggiore di 0",04:00:00,False
9,4.java,"Se il comando non è nullo, lo dividiamo in token. Se il token è uguale (ignorando lettere maiuscole/minuscole) a ""-help"" scriviamo in output la variabile usage e ritorniamo true. Se token è uguale a ""-vall"", showValues prende il valore di tutti i WantValues. Se token è uguale a ""-c"" e showValues è uguale a WantValues allora showValued prende come valore le coordinate di WantValued. Se token è uguale a "" -ncml"" allora la variabile ncml prende valore true. Se token è uguale a ""-cdl"" o è uguale a ""-strict"" la variabile strict la poniamo a true. Se token è uguale a ""-v"" ed abbiamo altri token a disposizione, la variabile varNames è uguale al prossimo token. Se token è uguale a ""-datasetname"" ed abbiamo token a disposizione, la variabile fakeDataset prende il prossimo token, se la lunghezza di fakeDataset è uguale a 0 poniamo la variabile a null; altrimenti se non è uguale a null, poniamo trueDataset uguale alla posizione della variabile nc e settiamo poi la variabile nc uguale alla posizione di fakeDataset",05:50:00,False
10,1.java,"Prendiamo tutti i file e li salviamo in un array File, se risulta vuoto lanciamo un eccezione. Se non è la radice e la lunghezza dell`array file è uguale a 0 allora ci salviamo l`ultima modifica del file, se risulta essere maggiore di persistMinutes, cancelliamo la cartella altrimenti lanciamo un eccezione. Se la variabile Formatter non è nulla, allora formattiamo tutti i log. Scorriamo tutti i file presenti nell'array file e richiamiamo ricorsivamente la funzione se incontriamo una cartella. Se incontriamo un file, ci salviamo l'ultima modifica effettuata su di esso e se risulta essere maggiore di persistMinutes allora cancelliamo il file. Se la rimozione non è andata a buon fine lanciamo un eccezione altrimenti formattiamo i log",05:30:00,False
11,3.java,"Se hashKey è nulla proviamo ad usare un altra chiave alternativa ovvero location.trueurl, se nel caso fosse ancora nulla allora solleviamo un eccezione.  Se trackAll è attivo allora manteniamo traccia di quanti accessi e mancati accessi ci sono nella cache per ogni chiave, usiamo un oggetto di tipo Tracker associato alla chiave e se già esiste allora lo andiamo a riutilizzare. Cerchiamo poi nella chace un file con quella stessa hashkey, se lo troviamo incrementiamo il contatore di hit e lo restituiamo subito altrimenti se il file non è in chace andiamo a registrare una chace miss aprendo il file tramite factory.open. Se il loggin è attivo stampiamo dei messaggi di log con informazioni sulla chace e sulla chiave. Se l'operazione viene annullata, chiudiamo il file e ritorniamo null. Se la chace è disabilitata ritorniamo il file aperto ma non lo inseriamo nella chace, altrimenti lo aggiungiamo ",04:47:00,False
12,1,"lo script effettua operazioni di cache cleaning, prende una lista di directory e controlla se la directory è root, prende il tempo attuale e la lista di file della directory, vede se non ci sono file nella directory allora da errore. entra nel secondo blocco quando non è root e ci sono file all'interno, vede quando è stata l'ultima volta che è stato modificato il file e controlla se quella ultima modifica è maggiore di un trashold, se maggiore allora prova ad eliminare la directory e controlla se è riuscito ad eliminarla. Il terzo blocco di codice itera sui file e se il file è una directory allora richiama la funzione cleancache ricorsivamente se non è una directory allora effettua lo stesso cnotrollo precedente sulla data dell'ultima modifica del file. ",06:40:00,True
13,2,"lo script controlla di che tipo è un array, instanzia un array che sarà il result, poi instanza un UBArray, poi crea uno swtich sul tipo che contiene l'array, se l'array contiene elementi di tipo int8 allora crea un array di tipo int8 allora retval diventa un array booleano dove gli elementi all'interno dell'array sono true se l'elemento all'interno dell'array UB è maggiore di 0, questo controllo all'interno dello swtich è uguale per int16, int32, int64, float32, float64. Se non è nessuno di queste tipologie allora lancia un eccezione, ritorna retval alla fine.",01:50:00,True
14,3,"lo script acquisisce un file all'interno di una cache, prima di tutto controlla se c'è una hash valida, se è null allora la crea dall'url corrente, se ancora è null lancia eccezione. nel primo blocco controlla crea un tracker poi controlla nel secondo blocco se un file è all'interno della cache in base alla hash e incrementa il valore della hash. Se il task è stato cancellato allora ritorna null dalla funzione. Alla fine inserisce il file nella cache.",05:30:00,False
15,4,"lo script praticamente stampa un comando inserito in una console, se il comando non è null allora crea un tokenizer e vede se nel comando sono state scritte determinate parole e per ogni valore cerca tramite showvalues tutti i possibili comandi correlati a quel valore scritto nel comando della console. alla fine crea un comando completo per stamparlo.",04:45:00,False
16,1,"Il codice prende tutti i files all'interno della cartella corrente, se il vettore dei files è null allora è avvenuto 
un errore e viene lanciata un'eccezione. Successivamente se l'utente è root ed è presente almeno un file nella
directory allora calcola la durata in minuti tra l'ultima modifica e l'avvio dello script, se è maggiore della durata
definita dalla soglia persistMinuts allora viene cancellata la cartella, viene infine generato un log in base 
all'avvenuta cancellazione o meno del file. Successivamente per ogni elemento all'interno della cartella, 
se esso è una cartella allora viene chiamata la funzione cleanCache, se non è una cartella allora calcola la durata in 
minuti tra l'ultima modifica e l'avvio dello script, se se è maggiore della durata definita dalla soglia persistMinuts
allora viene cancellato il file, viene infine generato un log in base all'avvenuta cancellazione o meno del file.",02:04:00,False
17,2,"Il codice prende in input un array di tipo UBArray, controlla il tipo degli elementi dell'UBArray fornito.In base a
quest'ultimo, per ogni elemento all'interno dell'array, effettua una conversione dell'elemento nel suo tipo primitivo.
I tipi sono: byte, short, int, long, float e double; vengono smistati attraverso uno switch. Crea, quindi, un vettore
di elementi booleani e, per ognuno, viene effettuata una trasformazione dal tipo di partenza al tipo booleano in
base al valore dell'elemento, se quest'ultimo è maggiore di 0 allora il valore sarà true, altrimenti false. Restituisce,
infine, il nuovo array dei tipi booleani.",02:00:00,True
18,3,"La funzione è un override, quindi la classe della funzione eredita alcuni elemente. La funzione in questione aggiunge
un file all'interno di una cache, il file può essere passato per argomento sia tramite hashkey che tramite url. 
Inizialmente controlla se il tracker debba tenere traccia di tutti i file all'interno della cache, se così allora aggiunge
il file all'interno della pool di tracking nel caso quest'ultimo non sia presente. Controlla se il file era già presente nella 
cache, se presente incrementa il numero di hit, altrimenti incrementa il numero di miss. Infine apre il file da rimuovere
per sostituire il file da aggiungere e ne acquisisce l'haskey. Nel caso siano state abilitati, verranno forniti i rispettivi
output (log, stdout) riguardo l'avvenuta acquisizione dell'hashkey. Infine viene rimosso il file da
rimuovere dalla cache e aggiunto il nuovo file all'interno della cache",08:42:00,False
19,4,"La funzione effettua una stampa di informazioni riguardo un dataset. Prende in input un comando e lo tokenizza,
per ogni token effettua uno smistamento in base al tipo di token ricevuto. Il comando ha una sintassi simile ai
comandi accettati da una shell. Se il comando fornito contiene i token: ""-help"" allora verrà stampata la documentazione
relativa al comando; ""-c"" e la flag  relativa alla volontà di ricevere più valori è true allora showValues avrà il valore
di coordsOnly; ""-ncml"" verrà attivata la flag di ncml; ""-cdl"" o ""-strict"" verrà attivata la flag di strict; ""-v"" si aspetta
un valore subito dopo e quel valore sarà il nome delle variabili da gestire; ""-datasetname"" si aspetta un valore
subito dopo e quel valore sarà il nome del dataset, in questo caso verrà salvata l'immagine corrente del dataset
per evitare modifiche involontarie a quest'ultimo. Infine effettua la stampa delle informazioni relative al comando 
fornito e viene ripristinato il dataset originale. Infine viene restituito un valore booleno in base al successo o meno
della stampa. ",02:55:00,True
20,3,"IL METODO SI OCCUPA DI ACQUISIRE UN FILE DATO IL SUO URL MANTENUTO NELL'OGGETTO LOCATION. IL FILE VIENE SCARICATO E POI AGGIUNTO ALLA CACHE. TUTTAVIA, IL TASK Può ESSERE CANCELLATO DALL'ESTERNO DEL METODO MANIPOLANDO UN FLAG.",,False
21,4,"IL METODO RICONOSCE I PARAMETRI INSERITI A RIGA DI COMANDO E AGISCE COME UNO SWITCH PER IMPOSTARE IL  CORRETTO MESSAGGIO DA MOSTRARE ALL'UTENTE. INOLTRE, DATO IL PARAMETRO DATASETNAME INSERITO DALL'UTENTE, INIZIALIZZA L'OGGETTO CORRISPONDENTE.",,False
22,1,"IL METODO CANCELLA I FILE NELLA CACHE, AGENDO RICORSIVAMENTE.",,False
23,2,"IL METODO PRENDE IN INPUT UN ARRAY DI NUMERI DI QUALSIASI TIPO, E RESTITUISCE UN ARRAY BOOLEANO DELLA STESSA DIMENSIONE, DOVE 1 INDICA CHE IL NUMERO DI PARTENZA ERA POSITIVO.",,False
24,1,"La funzione si occupa di pulire la Cache. Nella prima parte, la funzione salva nella variabile now il tempo corrente e la lista di files presenti nella directory. Nella seconda parte, nel caso in cui la directory non sia root e  la lista di files abbia lunghezza pari a 0, la funzione salva nella variabile duration il tempo intercorso tra now e l'ultima modifica alla directory. Procede poi a cancellare la directory nel caso in cui duration sia minore o uguale della variabile persistMinutes. Nella terza parte, si itera su ogni file. In tal caso, in base al risultato ottenuto dalla funzione isDirectory() si richiama ricorsivamente la funzione cleanCache(). Alternativamente, viene salvata la variabile duration come il tempo intercorso tra now e l'ultima modifica del file. Procede poi a cancellare il file nel caso in cui la variabile duration sia minore o uguale della variabile persistMinutes",4:34,False
25,2,"La funzione si occupa di convertrire un UBArray in un array booleano. Nella prima parte inizializza un array booleano retrval. Fa poi uno switch sul tipo dell'array. Per ogni tipo numerico supportato, estrae l'array primitivo, alloca l'array booleano e itera sui valori, setando ogni valore a true se il valore è positivo. Nella seconda parte se il tipo è non riconosciuro lancia una RuntimeException",3:51,True
26,3,"La funzione si occupa di restituire il nuovo file aperto in cache. Nella prima parte, la funzione si assicura che sia presente un'hashKey, lanciando un'eccezione nel caso in cui quest'ultima sia null. Nella seconda parte, nel caso in cui il tracking è abilitato, la variabile t veiene inizializzata con parametro hashKey. Si inizializza poi la variabile prev tramite la funzione putIfAbsent() e usando come parametri il Tracker t e l'hashkey. Nella terza parte si prova a fare un retrieval dalla cache. Nel caso venga trovato, si incerementa un contattore hits, alternativamente viene incrementato il contatore miss. Nella quarta parte si apre il file e si ottengono le informazioni nel caso in cui il debbugging sia enabled. Nella quinta parte si va a controllare se la variabile cancelTask sia non vuota e controlla se le operazioni siano state cancellate. In tal caso il file viene cluso e si restituisce null. Nella sesta parte, se la cache è disabilitata, viene restituito il file corrente, alternativamente si aggiunge il nuovo file alla cache associandolo all'hashkey. Quest'ultimo viene poi restituito",4:55,True
27,4,"La funzione si occupa di fare una print. Nella prima parte la funzione inizializza le variabili. Nella seconda parte, vengono effettuati dei controlli sulla stringa command solo se quest'ultima non è nulla. Si passa poi dalla variabile command alla variabile stoke, un'istanza della classe StringTokenizer inizializzata con la variabile command. Si inizia poi a lavorare iterativamente su stoke. Si prende il token successivo e viene salvato in toke. Nel caso in cui esso corrisponda alla stringa ""-help"" viene scritto in output la variabile usage e la stringa ""\n"". Poi, la funzione si ferma e restituisce true. Alternativamente, vengono fatti controlli aggiuntivi sulla variabile toke. Nel caso in cui toke corrisponda ad una specifica stringa (e.g.""-vall"", ""-c""). Nel caso in cui la variabile toke corrisponda alle stringhe ""-v"" e ""-datasetname"" viene fatto un controllo aggiuntivo su stoke, assicurandosi che stoke abbia altri token. Per quest'ultima stringa, viene fatta l'assegnazione ""fakeDataset = stoke.nextToken()"". Nel caso in cui fakeDataset abbia lunghezza pari a 0, fakeDataset viene settata a null. Se fakeDataset non è null, viene salvata nella variabile trueDataset la location del fakedataset. Nella terza parte viene chiamata ricorsivamente la funzione print. Vengono fatti poi dei controlli su fakeDataset e trueDataset, assicurandosi che essi non siano null. Viene poi fatto il setup della location e si ritorna la variabile ok",4:59,False
28,1,"Il metodo, dopo aver segnato l'ora corrente controlla se la cartella è valida e accessibile. Se la cartella non è root ed è vuota controlla se non è stata utilizzata per un periodo di tempo maggiore rispetto ad un tempo di persistenza. Se non è stata usata per un tempo maggiora cerca di eliminarla e di scrivere nel log il risultato dell'operazione. Tale procedimento viene ripetuto ricorsivametne per file e sottodirectory.",1:20,True
29,2,"Lo scopo del metodo è quello di restituire un array di booleani (retval) a partire da un oggetto di tipo UBArray (array) popolato mediante il metodo asArray. L'array di booleani è della stessa dimensione del numero di oggetti presenti nell'oggetti dell'array di tipo UBArray. L'ennesimo elemento di retval assume true se l'ennesimo elemento di array è true, altrimenti false.",10:00,False
30,3,"Lo scopo del metodo è quello di simulare il funzionamento di una memoria cache, in input viene dato la chiave hash del file, se questo viene trovato dal metodo acquireCacheOnly allora viene restituito, andando ad incrementare il numero di hit per quell'oggetto; in caso contrario viene aumentato il numero di miss per quel oggetto, viene cercato grazie al metodo open dell'oggetto factory alla location passata in input e poi memorizzato in cache prima di essere restituito.",6:10,False
31,4,Il metodo analizza i vari token di una stringa che rappresenta un comando al fine di riconoscere varie opzioni per il controllo dell'output del metodo print.,2:24,True
32,1,". Prima di tutto viene effettuato un controllo se la directory è effettivamente esistente successivamente se la directory risulta essere esistente viene effettuato un primo controllo per capire se la directory è di root, se risulta essere di root viene restituito un output con scritto ""Unable to delete file"", in caso contrario resituisce in output l'ora della modifica e dell'ultima modifica. Successivamene viene effettuato lo stesso controllo sui file della directory, se i file non possono essere eliminati restituisce in output ""Unable to delete file"" con il path assoluto dei file, in caso contrario elimina i file della directory restituendo in output il momento dell'ultima modifica.","5:13,04",False
33,2,"Nel seguente codice viene implementato uno switch case. In ogni case viene preso in considerazione un diverso tipo. Il primo caso un INT a 8 bit, successivamente un INT a 16 bit, 32 bit e 64 bit, float 32 e 64 bit. Per ogni caso viene dichierato un array  del tipo citato precedentemente (esempio per int a 8 bit: byte [], mentre per int a 16 bit: short [].) e estratti i valori di ogni array in ogni case dello switch case.","6:31,01",False
34,3,"Inizialmente si assicura che è presente un hashkey valido, lanciando un eccezione in caso contrario. Successivamente viene effettuato un controllo su Tracker, nel caso fosse abilitato crea o riceve un tracker per l'hashkey. Successivamente prova a prendere il file dalla cache, se trova update incrementa il contatore. Successivamente apre il file con lo scopo di loggare le acquisizioni ma solo se il debugging è abilitato. Infine viene effettuato un controllo sulla cancellazione, se positivo chiude il file e ritorna null. ","3:13,03",True
35,4,Lo scopo del codice analizzato è quello di analizzare diverse stringhe andando a modificare diverse variabili locali con la possibilità di modificare la location del NetCDF File solo se -datasetname viene utilizzata. Infine viene rimodificata la locazione del dataset se risulta essere temporaneamente modificata successivamente alla print.,"3:36,46",True
36, Script 2 ,"Scopo:
Lo scopo della funzione asBoolArray è quello di trasformare un array in un array equivalente i cui valori sono True se l’i-esimo elemento è maggiore di 0, False altrimenti

Input:
Non è passato alcun parametro in input alla funzione. Entrambi gli array con cui si lavora sono creati all’interno della funzione stessa

Output:
Se l’array di partenza creato (quello su cui devono essere eseguite le operazioni) è del tipo corretto, si effettua il return di un array booleano
Altrimenti si lancia un’eccezione

Logica principale:
Viene effettuato uno switch sul tipo dell’array creato, e in base a quest’ultimo vengono recuperati i suoi valori. Viene creato un array booleno della stessa lunghezza dell’array di partenza e vengono successivamente controllati i suoi elementi.
All’elemento dell’array di partenza maggiore di 0, si associa True nel nuovo array booleano.
All’elemento dell’array di partenza negativo, si associa False nel nuovo array booleano.
Se l’array che deve essere trasformato non è del tipo corretto, viene lanciata un’eccezione.
Infine, si ritorna il nuovo array booleano.
",10:31,False
37,Script 4,"Scopo:
Lo scopo della funzione, in base ad uno specifico comando batch, è quella di sostituire la locazione di un determinato dataset passato come parametro del comando
Input:
In input verrà preso:
-	Nc: il file che avrà il dataset
-	Command: il comanda batch
-	Out: è il writer che stampa a video i messaggi di aiuto
-	Ct: oggetto che serve per annullare le task in caso di problemi 

Output:
Un valore booleano che indica True se è stata successivamente cambiata la locazione del dataset, False altrimenti

Logica principale:
Oltre alla creazione di variabili per il funzionamento e successive chiamate,
viene effettuato un controllo sul comando che viene passato in input. Se tale comando non è vuoto, viene separato in token. Successivamente è effettuato un ciclo su tutti i token del comando, ed in base al loro contenuto vengono effettuate operazioni differenti.
Se il token è “-help” vengono stampati a schermo gli utilizzi del comando
Se il token è “-vall” vengono conservati in showValues i valori del dataset
Se il token è “-c” vengono conservate in showValues le coordinate dei valori del dataset
Se il token è “-ncml”, la variabile ncml è settata a True, che verrà successivamente utilzizata per la prossima chiamata a funzione. 
Stessa cosa per il token “-cdl” settando strict a True
Se invece il token è “-v” viene preso il nome delle variabili dal token successivo
Se invece il token è “-datasetname” e sono presenti altri token dopo questo ultimo, viene ripreso il fakedataset dal token successivo. Se non è vuoto, si crea un dataset (truedataset) che possiede i dati del file nc passato in input. Successivamente viene inserito in nc il contenuto di fakedataset.
Infine viene richiamata tale funzione principale in maniera ricorsiva fino a che il contenuto di entrambi i dataset non sia vuoto.
Se ci dovessero essere dei problemi di Scrittura input/output, il programma si fermerà
",19:48,False
38,Script 1,"Scopo:
Ripulire/Eliminare file la cui ultima modifica supera un certo periodo di tempo

Input:
La funzione prende in input una directory, un formattatore di File e un booleano

Output:
Siccome la funzione è void, non è presente alcun output

Logica principale:
Se il file passato in input è Null, viene lanciata un’eccezione.
Altrimenti vengono effettuati dei controlli sul file passato. Se è una directory non è la root, ed è vuota, controlla quando è stata effettuata l’ultima modifica alla cartella stessa. Se supera un certo ammontare id tempo, tenta di cancellarla. Se si verifica un errore, viene mostrato. Tale metodo, una volta effettuate queste operazioni, ritorna subito per evitare si compiere ulteriori operazioni.
Se questo non avviene (e quindi la cartella non è vuota), si controlla ogni file, ed eventualmente anche sottocartella in maniera ricorsiva. Per ogni file, se l’ultima modifica supera l’ammontare di tempo definito le cancella se necessario. Infine, viene controllato che ogni file è pulito secondo la policy
",8:10,True
39,Script 3,"Scopo:
Lo scopo della funzione è recuperare un file dalla cache e gestirlo se già presente

Input:
-	Factory: per gestire i file
-	Hashkey: per associare i file ad un codice
-	Location: l’url del file
-	Buffer-szie: la dimensione del buffer
-	Cancel task: per gestire eventuali problemi

Output:
Il file

Logica principale:
Una volta passato in input l’haskey, si controlla se è disponibile per il lookup. Se non è presente un haskey si tenta di riprenderlo dalla location dell’url, altrimenti si lancia un eccezione.
Successivamente è creato un tracker, per gestire l’uso della cache dell’hashkey. Se un tracker è già presente, lo riusa.
Cerca di riprendere il file dalla cache utilizzando l’hashkey e caricare il file.
Se il file non è presente nella cache, lo apre con l’apposita factory, stampando in console le informazioni di debug.
Se l’operazione non è andata a buon fine, e quindi è stata annullata dal cancel task, ritorna null, bloccando l’intero processo.
Se la cache è disabilitata, il nuovo file viene aggiunto alla cache, associandolo con un’hashkey.
Ritorna il nuovo file
",8:30,True
40,2,dato un array di numeri(di qualsiasi tipo) ritorna un array booleano che segue la logica if valore>0 true altrimenti false,03:00:00,True
41,3,"se il tracking è attivo va a cercare file all'interno della cache, se li trova aumenta il counter altrimenti aumenta quello dei mancati",06:00:00,True
42,4,prende in input un comando tramite stringa e in base all'input esegue il comando corrispondente,02:00:00,False
43,1,"data una root va ad eliminare file per file, se trova una directory riesegue la funzione ricorsivamente",03:00:00,False
44,cleanCache,"Lo script permette di effettuare una pulizia della cache. Gestisce il caso in cui la directory corrente non è la root oppure risulta vuota ed effettua un'iterazione ricorsiva per ogni subdirectory, controllando lo se ogni file deve restare in cache o meno.",00:00:36,True
45,asBoolArray,"Lo script permette di trasformare vari tipi di dati primitivi (interi e float) in un array booleano, allocato tramite memoria heap.",00:00:45,False
46,acquire,"Lo script, dopo aver controllato lo stato della cache, permette di aggiungervi un file al suo interno. Viene utilizzata una hashtable per memorizzare le coppie key-value di file e hash ed è presente un sistema di cancellamento del task.",00:01:10,False
47,print,"Lo script prendere in input una comando che è una stringa, un buffer di output e altri parametri aggiuntivi. Effettua il parsing del comando controllando se esistono token di flag validi nel comando ed esegue l'operazione relativa alla flag se il token è corretto. È disponibile una ""-help"" flag per documentarsi sull'utilizzo.",00:00:54,True
48,1,"Lo scopo di questo script è quello  di ripulire la cache di una directory e non sono restituiti output
Gli input sono:
 - Un'istanza dir della classe File
 - Un'istanza sbuffer della classe Formatter
 - Una variabile isRoot di tipo boolean
Non ci sono output
La logica di questo script prevede:
 - Si recupera il tempo iniziale nella variabile now
 - Si recuperano i file da dir
 - Se l'array files è null viene sollevata l'eccezione IllegalStateException
 - Nel branch then relativo al controllo che isRoot sia false e l'array di files sia vuoto, si recupera il tempo dell'ultimo file modificato nella directory e se questo tempo è superiore a persistMinutes, viene cancellata la directory andando ad effettuare il log sia in caso di cancellazione con successo che con insuccesso e infine si esce dallo script tramite una return
 - Con il for successivo, si vanno ad esplorare e cancellare ricorsivamente tutti i file ed eventuali subdirectory, seguendo una logica simile a quella del branch then relativo al controllo che isRoot sia false e l'array di files sia vuoto
 - Si esce dallo script (senza nessuna return) per la fine del codice",05:15:00,True
49,2,"Lo scopo di questo script è quello di convertire un array numerico in booleano
Non ci sono input
Gli output sono:
 - L'array retval di tipo boolean
La logica di questo script prevede:
 - Si definisce l'array retval di tipo boolean
 - Si definisce l'istanza array della classe UBArray e viene assegnato il valore di output di asArray()
 - Lo switch rispetto al valore restituito da array.getStrongType() prevede vari casi, a seconda del tipo numerico (Int8, Int16, Int32, Int64, Float32, Float64) per convertire un array numerico in booleano a seconda dei valori che contiene (se > 0 allora true, false altrimenti)
 - Si resituisce retval",02:22:00,True
50,3,"Lo scopo di questo script è quello di creare o individuare un file da ""cachare"" che viene poi restituito all'utente. 
Gli input sono:
 - Un'istanza factory della classe FileFactory
 - Un'istanza hashkey della classe Object
 - Un'istanza location della classe DatasetUrl
 - Una variabile buffer_size di tipo int
 - Un'istanza cancelTask della classe CancelTask
 - Un'istanza spiObject della classe Object
Gli output sono:
 - Un'istanza ncfile della classe FileCacheable
La logica di questo script prevede:
 - Doppio controllo sulla haskey nel caso il suo contenuto continui ad essere null anche dopo avergli assegnato il valore location.trueurl
 - Definizione dell'istanza t della classe Tracker e se passa il controllo su trackAll, t viene istanziata con il costruttore passando come parametro hasKey
 - Nel branch then relativo al controllo su trackAll, viene recuperato prev e se è diverso da null, adesso t punterà a prev
 - Il valore di ncfile viene assegnato mediante acquireCacheOnly(hasKey) e se passa il controllo a diverso da null di ncfile, si esegue hits.incrementAndGet
 - Nel branch then relativo al controllo a diverso da null di ncfile, c'è un'ulteriore controllo a diverso da null di t, che se passa incrementerà l'attributo hit di t
 - Al termine di questo branch, c'è una prima possibile restituizione di ncfile
 - Se non si entra nel branch then relativo al controllo a null di ncfile, si esegue miss.incrementAndGet e si incremente l'attributo miss di t solamente se t è diverso da null
 - Viene assegnato un nuovo valore a ncfile mediante l'esecuzione di factory.open(location, buffer_size, cancelTask, spiObject)
 - Se passa il controllo relativo al valore booleano di cacheLog.isDebugEnabled(), si scrive nel log di debug con il messaggio ""FileCacheARC "" + name + "" acquire "" + hashKey + "" "" + ncfile.getLocation()
 - Se passa il controllo relativo al valore booleano di debugPrint, si scrive a schermo sulla shell prinicpale lo stesso messaggio del log
 - Se passa il controllo relativo all'and tra cancelTask diverso da null e cancelTask.isCancel (il task è stato cancellato?), si controlla che ncfile sia diverso da null e nel caso lo sia, il file viene chiuso prima di restituire il valore null
 - Se passa il controllo disabled.get() si restituisce ncfile
 - Si esegue addToCache(hashkey, ncfile) per aggiungere il file nella cache
 - Si restituisce ncfile",08:40:00,False
51,4,"Lo scopo di questo script è quello di processare un comando e analizzare i suoi eventuali argomenti che potrebbero scrivere in output dei messaggi.
Gli input sono:
 - Un'istanza nc della classe NetcdFile
 - Una stringa command
 - Un'istanza out della classe Writer
 - Un'istanza ct della classe ucar.nc2.util.CancelTask
Gli output sono:
 - Il valore booleano della variabile ok
Inoltre può essere sollevata l'eccezione IoException
La logica di questo script prevede:
 - Vengono definiti i valori per le istanze e variabili shoValues di classe WantValues, ncml di tipo boolean, strict di tipo boolean, varNames di tipo String, trueDataset di tipo String, fakeDataset di tipo String
 - Nel branch then relativo al controllo diverso da null di command, si definisce il valore dell'istanza stoke di classe StringTokenizer tramite il costruttore passando come argomento command
 - Nel while all'interno del branch then relativo al controllo diverso da null di command, si recupera il token successivo tramite stoke.nextToken() e viene memorizzato in toke
 - Seguono vari controlli (sempre nel while) per il valore di toke, per stabilire quali sono i parametri usati nel comando e a seconda del parametro, sono assegnati i nuovi valori delle variabili e istanze definite inizialmente
 - Al di fuori del while e del branch, viene nuovamente richiamato su se stesso il metodo print e si recupera l'output
 - Se trueDaatset e fakeDataset sono entrambi diversi da null, si esegue nc.setLocation(trueDataset)
 - Si restituisce ok",07:15:00,False
52,3,"Ricerca di un file tramite una chiave e restituzione del file e aggiunta del file ad una cache. Viene aperta la cache tramite la chiave. In caso il debug sia attivo si stampa il nome del FileCacheARC, la chiave di accesso alla cache e la locazione del file. Alla fine viene restituito il file e viene aggiunta alla cache il file e l'hashkey",5,False
53,4,"Si prendono dei comandi, in caso il comando sia -help si stampa come si utilizza e si restituisce true. A seconda dei comandi dati, si stampano informazioni relative ad un dataset dove il nome del dataset viene preso dopo il comando -datasetname. Se è stato scritto effettivamente il nome del dataset allora si recupera la location. ",5,False
54,2,"Il codice riguarda una funzione utilizzata per trasformare un array di varie tipologie di numeri in un array di booleani. A seconda del tipo dell'array vengono convertiti i dati all'interno in true o false, ad esempio se sono byte ogni byte è convertito in un booleano. Se è > 0 viene salvato true nel nuovo array da restituire, altrimenti è false. Viene fatta la stessa cosa per gli short, per gli int, per i long, per i float, i double. Lancia un exception se il tipo dell'array non è supportato. ",7,True
55,1,"Il codice pulisce le cartelle dai file che non sono stati utilzzati da tanto tempo. Viene pulito ricorsivamente tutto quello che non è stato modificato per un tempo ben predefinito. Quindi prima prova ad aprire la cartella, se non trova la cartella da errore. Poi controlla se il file non viene modificato da un bel po' di tempo, dopo aver controllato che non sia la root o la cartella sia vuota; se è stato modificato molto tempo fa allora viene cancellato. Si cicla su ogni file di una cartella, se è il file è una cartella viene richiamata la funzione ricorsivamente sui file della cartella ""interna"". Si rifà il controllo se il file non viene modificato da tanto tempo, in caso si cerca di eliminarlo, altrimenti si stampa un log di errore. ",5,True
56,1,"Delete old files (if last modification time is more than persistMinutes, which is not defined) in a given directory and its subdirectory (using a recursive algorithm).
The deletion of a directory is done only if non root (?) ",03:00:00,False
57,2,"Convert an array obtained fron asArray() (I don't know where this comes from) into a boolean array. Basically, if a value is greater than 0, it's True, else False. There's a switch case for the various numerical data types, though it seems not needed.",,False
58,3,"I didn't really get it, but it should be something about the creation of a file into a certain cache. Even with explanations, it's very difficult to get what this does",,True
59,4,"The method consumes certain string from command line, processing the variosu flags and options. The various options enable certain flags. I didn't get the role of this netcdfile object",,True
60,3,"Scopo: acquisizione di un oggetto FileCachable utilizzando la cache o la factory -> Input: Factory per aprire il file, haskey del file, location in caso di hashkey nulla, taglia del buffer e valore booleano per cancellazione del task -> Output: oggetto FileCachable -> si ricerca il file nella cache, se lo si trova si ritorna il file altrimenti si tenta di aprirlo tramite la factory. Se è prevista la cancellazione del task, il file è chiuso e non viene restituito. ",03:56:00,True
61,4,"Scopo: parsing di un comando -> Input: file, stringa di un comando, output e booleano per cancellare task -> Ouput: successo del parsing della stringa con salvataggio della posizione del file -> Il codice estrae i parametri da una stringa che rappresenta un comando",04:22:00,True
62,1,"Scopo: pulizia della cache -> Input: directory in cui eliminare i file, booleano per indicare se la directory è una radice  -> Output: non presente -> Se la directory è vuota e non è una radice, se non è stata modificata di recente viene cancellata. Se invece sono presenti dei file viene fatto lo stesso per ogni file",03:20:00,False
63,2,"Scopo: conversione di un array di numeri in un array di booleani -> Input: array di valori -> Output: array di booleani -> Identificazione tramite switch del tipo dei valori dell'array di input e creazione di un nuovo array in cui i valori in posizione i sono pari a True se il valore in posizione i nell'array di input è positivo, False altrimenti.",02:29:00,False
64,1,"Lo script contiene l'implementazione di un metodo per effettuare la pulizia della cache di una directory data in base all'ultima volta che è stata modificata. Si effettuano dei controlli preliminari sulla validità del percorso della cartella da rimuovere, se è una cartella root o contiene almeno un file. Nel caso in cui fosse una directory non root con almeno un file, calcola il tempo trascorso dall'ultima modifica nella cartella. Se il tempo trascorso supera un valore soglia, prova a rimuovere la cartella; in caso contrario, segnala l'errore di rimozione. Nel caso in cui la directory data è root, scansiona i file al suo interno: per una directory, richiama il metodo cleanCache; per un file regolare, calcola il tempo trascorso dall'ultima volta che è stato modificato il file. Se il tempo trascorso supera un valore soglia, prova a rimuovere il file; in caso contrario, dichiara l'errore di rimozione. ",00:03:39,True
65,3,"Si tratta dell'implementazione di un metodo per gestire la cancellazione, l'inserimento e/o la ricerca di un file in una cache. Si effettuano dei controlli preliminari sulla validità dell'hash key fornita per fare il recupero del file. Se il file è stato recuperato correttamente dalla cache, viene incrementato il numero di cache hint; in caso contrario viene incrementato il valore di cache miss. Se il file non viene trovato nella cache allora il file viene aperto e, se è richiesto, mostra il suo contenuto a schermo. Infine, se è richiesta la cancellazione del file, non si procede con l'acquisizione del file nella cache; altrimenti, aggiunge il file alla cache.",00:05:48,True
66,2,"È un metodo che, preso in input un array di interi o di float, genera un array booleano dove l'i-esimo elemento dell'array booleano è: True se l'i-esimo elemnto dell'array di interi/float è un numero positivo; altrimenti, False.",00:03:52,False
67,4,"Il metodo richiede in input una stringa e verifica se corrisponde ad uno dei comandi noti (es. -help, -c, -vall, ...). Nel caso del comando -help, viene visualizzato un messaggio di guida per l'utilizzo. Nel caso di comandi '""-ncml"", ""-cdl"", ""-strict"" imposta dei flag atti a confermare la presenza del comando. Nel caso del comando ""-datasetname"", viene recuperato il dataset richiesto tramite pathname con la funzione getLocation(). Infine, viene eseguita una funzione che si occupa di stampare il comando immesso, gli eventuali parametri dei comandi.",00:04:23,False
68,2,"Abbiamo una funzione che restituisce un booleano. Una volta inizializzato UBAarry c'è uno switch che va ad testare su ongi caso che possono essere, int8, int16, int32, int64, float32 e 64. In ogni case va ad iterare sulla lunghezza dell'arry e una volta fatto ciò va a convertire se il valore è maggiore di 0.",04:04:00,True
69,4,Abbiamo una funzione che si occupa di instanziare un tokenizer che serve per le stringhe in Java e c'è un semplice while dove finchè c'è ancora qualcosa da leggere prende tutto quello che legge e in base a quello che trova se entra in un if mette quello che trova a true. Fatto ciò va a chiamare la funzione print che si occupa di stamapre tutto quello necessario.,01:48:00,True
70,1,Abbiamo una funzione che si occupa di eliminare dei file. Il primo if controlla se ci sono file se non ci sono lancia un exception. Nel secondo if credo che quell isRoot controlli se si hanno i permessi e se con i minuti corrispondono ma sopratutto se sono stati eliminati tutti i file. Se è tutto ok allora elimina la cartella altrimenti si possono anadare in if in caso di errore e non eliminare. Abbiamo un for principale che si occupa di chiamare la funzione e svolgere il tutto.,02:32:00,False
71,3, Questa funzione si occupa di acquisire file. Nel primo if prende solo file che possono solo essere cachati se non è diverso da null allora va bene. Andando avanti nel file java scrive delle cose sul file una volta fatto questo lo aggiunge alla cache e restituisce il file.,04:14:00,False
