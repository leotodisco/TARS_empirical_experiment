{"samples": [{"repo": "DigitalPebble/storm-crawler", "path": "core/src/main/java/com/digitalpebble/stormcrawler/filtering/basic/BasicURLNormalizer.java", "func_name": "BasicURLNormalizer.processQueryElements", "original_string": "private String processQueryElements(String urlToFilter) {\n        try {\n            // Handle illegal characters by making a url first\n            // this will clean illegal characters like |\n            URL url = new URL(urlToFilter);\n\n            String query = url.getQuery();\n            String path = url.getPath();\n\n            // check if the last element of the path contains parameters\n            // if so convert them to query elements\n            if (path.contains(\";\")) {\n                String[] pathElements = path.split(\"/\");\n                String last = pathElements[pathElements.length - 1];\n                // replace last value by part without params\n                int semicolon = last.indexOf(\";\");\n                if (semicolon != -1) {\n                    pathElements[pathElements.length - 1] = last.substring(0,\n                            semicolon);\n                    String params = last.substring(semicolon + 1).replaceAll(\n                            \";\", \"&\");\n                    if (query == null) {\n                        query = params;\n                    } else {\n                        query += \"&\" + params;\n                    }\n                    // rebuild the path\n                    StringBuilder newPath = new StringBuilder();\n                    for (String p : pathElements) {\n                        if (StringUtils.isNotBlank(p)) {\n                            newPath.append(\"/\").append(p);\n                        }\n                    }\n                    path = newPath.toString();\n                }\n            }\n\n            if (StringUtils.isEmpty(query)) {\n                return urlToFilter;\n            }\n\n            List<NameValuePair> pairs = URLEncodedUtils.parse(query,\n                    StandardCharsets.UTF_8);\n            Iterator<NameValuePair> pairsIterator = pairs.iterator();\n            while (pairsIterator.hasNext()) {\n                NameValuePair param = pairsIterator.next();\n                if (queryElementsToRemove.contains(param.getName())) {\n                    pairsIterator.remove();\n                } else if (removeHashes && param.getValue() != null) {\n                    Matcher m = thirtytwobithash.matcher(param.getValue());\n                    if (m.matches()) {\n                        pairsIterator.remove();\n                    }\n                }\n            }\n\n            StringBuilder newFile = new StringBuilder();\n            if (StringUtils.isNotBlank(path)) {\n                newFile.append(path);\n            }\n            if (!pairs.isEmpty()) {\n                Collections.sort(pairs, comp);\n                String newQueryString = URLEncodedUtils.format(pairs,\n                        StandardCharsets.UTF_8);\n                newFile.append('?').append(newQueryString);\n            }\n            if (url.getRef() != null) {\n                newFile.append('#').append(url.getRef());\n            }\n\n            return new URL(url.getProtocol(), url.getHost(), url.getPort(),\n                    newFile.toString()).toString();\n        } catch (MalformedURLException e) {\n            LOG.warn(\"Invalid urlToFilter {}. {}\", urlToFilter, e);\n            return null;\n        }\n    }", "language": "java", "code": "private String processQueryElements(String urlToFilter) {\n        try {\n            // Handle illegal characters by making a url first\n            // this will clean illegal characters like |\n            URL url = new URL(urlToFilter);\n\n            String query = url.getQuery();\n            String path = url.getPath();\n\n            // check if the last element of the path contains parameters\n            // if so convert them to query elements\n            if (path.contains(\";\")) {\n                String[] pathElements = path.split(\"/\");\n                String last = pathElements[pathElements.length - 1];\n                // replace last value by part without params\n                int semicolon = last.indexOf(\";\");\n                if (semicolon != -1) {\n                    pathElements[pathElements.length - 1] = last.substring(0,\n                            semicolon);\n                    String params = last.substring(semicolon + 1).replaceAll(\n                            \";\", \"&\");\n                    if (query == null) {\n                        query = params;\n                    } else {\n                        query += \"&\" + params;\n                    }\n                    // rebuild the path\n                    StringBuilder newPath = new StringBuilder();\n                    for (String p : pathElements) {\n                        if (StringUtils.isNotBlank(p)) {\n                            newPath.append(\"/\").append(p);\n                        }\n                    }\n                    path = newPath.toString();\n                }\n            }\n\n            if (StringUtils.isEmpty(query)) {\n                return urlToFilter;\n            }\n\n            List<NameValuePair> pairs = URLEncodedUtils.parse(query,\n                    StandardCharsets.UTF_8);\n            Iterator<NameValuePair> pairsIterator = pairs.iterator();\n            while (pairsIterator.hasNext()) {\n                NameValuePair param = pairsIterator.next();\n                if (queryElementsToRemove.contains(param.getName())) {\n                    pairsIterator.remove();\n                } else if (removeHashes && param.getValue() != null) {\n                    Matcher m = thirtytwobithash.matcher(param.getValue());\n                    if (m.matches()) {\n                        pairsIterator.remove();\n                    }\n                }\n            }\n\n            StringBuilder newFile = new StringBuilder();\n            if (StringUtils.isNotBlank(path)) {\n                newFile.append(path);\n            }\n            if (!pairs.isEmpty()) {\n                Collections.sort(pairs, comp);\n                String newQueryString = URLEncodedUtils.format(pairs,\n                        StandardCharsets.UTF_8);\n                newFile.append('?').append(newQueryString);\n            }\n            if (url.getRef() != null) {\n                newFile.append('#').append(url.getRef());\n            }\n\n            return new URL(url.getProtocol(), url.getHost(), url.getPort(),\n                    newFile.toString()).toString();\n        } catch (MalformedURLException e) {\n            LOG.warn(\"Invalid urlToFilter {}. {}\", urlToFilter, e);\n            return null;\n        }\n    }", "code_tokens": ["private", "String", "processQueryElements", "(", "String", "urlToFilter", ")", "{", "try", "{", "// Handle illegal characters by making a url first", "// this will clean illegal characters like |", "URL", "url", "=", "new", "URL", "(", "urlToFilter", ")", ";", "String", "query", "=", "url", ".", "getQuery", "(", ")", ";", "String", "path", "=", "url", ".", "getPath", "(", ")", ";", "// check if the last element of the path contains parameters", "// if so convert them to query elements", "if", "(", "path", ".", "contains", "(", "\";\"", ")", ")", "{", "String", "[", "]", "pathElements", "=", "path", ".", "split", "(", "\"/\"", ")", ";", "String", "last", "=", "pathElements", "[", "pathElements", ".", "length", "-", "1", "]", ";", "// replace last value by part without params", "int", "semicolon", "=", "last", ".", "indexOf", "(", "\";\"", ")", ";", "if", "(", "semicolon", "!=", "-", "1", ")", "{", "pathElements", "[", "pathElements", ".", "length", "-", "1", "]", "=", "last", ".", "substring", "(", "0", ",", "semicolon", ")", ";", "String", "params", "=", "last", ".", "substring", "(", "semicolon", "+", "1", ")", ".", "replaceAll", "(", "\";\"", ",", "\"&\"", ")", ";", "if", "(", "query", "==", "null", ")", "{", "query", "=", "params", ";", "}", "else", "{", "query", "+=", "\"&\"", "+", "params", ";", "}", "// rebuild the path", "StringBuilder", "newPath", "=", "new", "StringBuilder", "(", ")", ";", "for", "(", "String", "p", ":", "pathElements", ")", "{", "if", "(", "StringUtils", ".", "isNotBlank", "(", "p", ")", ")", "{", "newPath", ".", "append", "(", "\"/\"", ")", ".", "append", "(", "p", ")", ";", "}", "}", "path", "=", "newPath", ".", "toString", "(", ")", ";", "}", "}", "if", "(", "StringUtils", ".", "isEmpty", "(", "query", ")", ")", "{", "return", "urlToFilter", ";", "}", "List", "<", "NameValuePair", ">", "pairs", "=", "URLEncodedUtils", ".", "parse", "(", "query", ",", "StandardCharsets", ".", "UTF_8", ")", ";", "Iterator", "<", "NameValuePair", ">", "pairsIterator", "=", "pairs", ".", "iterator", "(", ")", ";", "while", "(", "pairsIterator", ".", "hasNext", "(", ")", ")", "{", "NameValuePair", "param", "=", "pairsIterator", ".", "next", "(", ")", ";", "if", "(", "queryElementsToRemove", ".", "contains", "(", "param", ".", "getName", "(", ")", ")", ")", "{", "pairsIterator", ".", "remove", "(", ")", ";", "}", "else", "if", "(", "removeHashes", "&&", "param", ".", "getValue", "(", ")", "!=", "null", ")", "{", "Matcher", "m", "=", "thirtytwobithash", ".", "matcher", "(", "param", ".", "getValue", "(", ")", ")", ";", "if", "(", "m", ".", "matches", "(", ")", ")", "{", "pairsIterator", ".", "remove", "(", ")", ";", "}", "}", "}", "StringBuilder", "newFile", "=", "new", "StringBuilder", "(", ")", ";", "if", "(", "StringUtils", ".", "isNotBlank", "(", "path", ")", ")", "{", "newFile", ".", "append", "(", "path", ")", ";", "}", "if", "(", "!", "pairs", ".", "isEmpty", "(", ")", ")", "{", "Collections", ".", "sort", "(", "pairs", ",", "comp", ")", ";", "String", "newQueryString", "=", "URLEncodedUtils", ".", "format", "(", "pairs", ",", "StandardCharsets", ".", "UTF_8", ")", ";", "newFile", ".", "append", "(", "'", "'", ")", ".", "append", "(", "newQueryString", ")", ";", "}", "if", "(", "url", ".", "getRef", "(", ")", "!=", "null", ")", "{", "newFile", ".", "append", "(", "'", "'", ")", ".", "append", "(", "url", ".", "getRef", "(", ")", ")", ";", "}", "return", "new", "URL", "(", "url", ".", "getProtocol", "(", ")", ",", "url", ".", "getHost", "(", ")", ",", "url", ".", "getPort", "(", ")", ",", "newFile", ".", "toString", "(", ")", ")", ".", "toString", "(", ")", ";", "}", "catch", "(", "MalformedURLException", "e", ")", "{", "LOG", ".", "warn", "(", "\"Invalid urlToFilter {}. {}\"", ",", "urlToFilter", ",", "e", ")", ";", "return", "null", ";", "}", "}"], "docstring": "Basic filter to remove query parameters from urls so parameters that\ndon't change the content of the page can be removed. An example would be\na google analytics query parameter like \"utm_campaign\" which might have\nseveral different values for a url that points to the same content. This\nis also called when removing attributes where the value is a hash.", "docstring_tokens": ["Basic", "filter", "to", "remove", "query", "parameters", "from", "urls", "so", "parameters", "that", "don", "t", "change", "the", "content", "of", "the", "page", "can", "be", "removed", ".", "An", "example", "would", "be", "a", "google", "analytics", "query", "parameter", "like", "utm_campaign", "which", "might", "have", "several", "different", "values", "for", "a", "url", "that", "points", "to", "the", "same", "content", ".", "This", "is", "also", "called", "when", "removing", "attributes", "where", "the", "value", "is", "a", "hash", "."], "sha": "5d0465192ab8fbd89a90db32cb20960a282411ea", "url": "https://github.com/DigitalPebble/storm-crawler/blob/5d0465192ab8fbd89a90db32cb20960a282411ea/core/src/main/java/com/digitalpebble/stormcrawler/filtering/basic/BasicURLNormalizer.java#L232-L308", "partition": "test", "cyclomatic_complexity": 16}, {"repo": "Unidata/thredds", "path": "dap4/d4servlet/src/main/java/dap4/servlet/DapController.java", "func_name": "DapController.handleRequest", "original_string": "public void\n    handleRequest(HttpServletRequest req, HttpServletResponse res)\n            throws IOException\n    {\n        DapLog.debug(\"doGet(): User-Agent = \" + req.getHeader(\"User-Agent\"));\n        if(!this.initialized) initialize();\n        DapRequest daprequest = getRequestState(req, res);\n        String url = daprequest.getOriginalURL();\n        StringBuilder info = new StringBuilder(\"doGet():\");\n        info.append(\" dataset = \");\n        info.append(\" url = \");\n        info.append(url);\n        if(DEBUG) {\n            System.err.println(\"DAP4 Servlet: processing url: \" + daprequest.getOriginalURL());\n        }\n        DapContext dapcxt = new DapContext();\n        // Add entries to the context\n        dapcxt.put(HttpServletRequest.class, req);\n        dapcxt.put(HttpServletResponse.class, res);\n        dapcxt.put(DapRequest.class, daprequest);\n\n        ByteOrder order = daprequest.getOrder();\n        ChecksumMode checksummode = daprequest.getChecksumMode();\n        dapcxt.put(Dap4Util.DAP4ENDIANTAG, order);\n        dapcxt.put(Dap4Util.DAP4CSUMTAG, checksummode);\n        // Transfer all other queries\n        Map<String, String> queries = daprequest.getQueries();\n        for(Map.Entry<String, String> entry : queries.entrySet()) {\n            if(dapcxt.get(entry.getKey()) == null) {\n                dapcxt.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        if(url.endsWith(FAVICON)) {\n            doFavicon(FAVICON, dapcxt);\n            return;\n        }\n\n        String datasetpath = DapUtil.nullify(DapUtil.canonicalpath(daprequest.getDataset()));\n        try {\n            if(datasetpath == null) {\n                // This is the case where a request was made without a dataset;\n                // According to the spec, I think we should return the\n                // services/capabilities document\n                doCapabilities(daprequest, dapcxt);\n            } else {\n                RequestMode mode = daprequest.getMode();\n                if(mode == null)\n                    throw new DapException(\"Unrecognized request extension\")\n                            .setCode(HttpServletResponse.SC_BAD_REQUEST);\n                switch (mode) {\n                case DMR:\n                    doDMR(daprequest, dapcxt);\n                    break;\n                case DAP:\n                    doData(daprequest, dapcxt);\n                    break;\n                case DSR:\n                    doDSR(daprequest, dapcxt);\n                    break;\n                default:\n                    throw new DapException(\"Unrecognized request extension\")\n                            .setCode(HttpServletResponse.SC_BAD_REQUEST);\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n            int code = HttpServletResponse.SC_BAD_REQUEST;\n            if(t instanceof DapException) {\n                DapException e = (DapException) t;\n                code = e.getCode();\n                if(code <= 0)\n                    code = DapCodes.SC_BAD_REQUEST;\n                e.setCode(code);\n            } else if(t instanceof FileNotFoundException)\n                code = DapCodes.SC_NOT_FOUND;\n            else if(t instanceof UnsupportedOperationException)\n                code = DapCodes.SC_FORBIDDEN;\n            else if(t instanceof MalformedURLException)\n                code = DapCodes.SC_NOT_FOUND;\n            else if(t instanceof IOException)\n                code = DapCodes.SC_BAD_REQUEST;\n            else\n                code = DapCodes.SC_INTERNAL_SERVER_ERROR;\n            senderror(daprequest, code, t);\n        }//catch\n    }", "language": "java", "code": "public void\n    handleRequest(HttpServletRequest req, HttpServletResponse res)\n            throws IOException\n    {\n        DapLog.debug(\"doGet(): User-Agent = \" + req.getHeader(\"User-Agent\"));\n        if(!this.initialized) initialize();\n        DapRequest daprequest = getRequestState(req, res);\n        String url = daprequest.getOriginalURL();\n        StringBuilder info = new StringBuilder(\"doGet():\");\n        info.append(\" dataset = \");\n        info.append(\" url = \");\n        info.append(url);\n        if(DEBUG) {\n            System.err.println(\"DAP4 Servlet: processing url: \" + daprequest.getOriginalURL());\n        }\n        DapContext dapcxt = new DapContext();\n        // Add entries to the context\n        dapcxt.put(HttpServletRequest.class, req);\n        dapcxt.put(HttpServletResponse.class, res);\n        dapcxt.put(DapRequest.class, daprequest);\n\n        ByteOrder order = daprequest.getOrder();\n        ChecksumMode checksummode = daprequest.getChecksumMode();\n        dapcxt.put(Dap4Util.DAP4ENDIANTAG, order);\n        dapcxt.put(Dap4Util.DAP4CSUMTAG, checksummode);\n        // Transfer all other queries\n        Map<String, String> queries = daprequest.getQueries();\n        for(Map.Entry<String, String> entry : queries.entrySet()) {\n            if(dapcxt.get(entry.getKey()) == null) {\n                dapcxt.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        if(url.endsWith(FAVICON)) {\n            doFavicon(FAVICON, dapcxt);\n            return;\n        }\n\n        String datasetpath = DapUtil.nullify(DapUtil.canonicalpath(daprequest.getDataset()));\n        try {\n            if(datasetpath == null) {\n                // This is the case where a request was made without a dataset;\n                // According to the spec, I think we should return the\n                // services/capabilities document\n                doCapabilities(daprequest, dapcxt);\n            } else {\n                RequestMode mode = daprequest.getMode();\n                if(mode == null)\n                    throw new DapException(\"Unrecognized request extension\")\n                            .setCode(HttpServletResponse.SC_BAD_REQUEST);\n                switch (mode) {\n                case DMR:\n                    doDMR(daprequest, dapcxt);\n                    break;\n                case DAP:\n                    doData(daprequest, dapcxt);\n                    break;\n                case DSR:\n                    doDSR(daprequest, dapcxt);\n                    break;\n                default:\n                    throw new DapException(\"Unrecognized request extension\")\n                            .setCode(HttpServletResponse.SC_BAD_REQUEST);\n                }\n            }\n        } catch (Throwable t) {\n            t.printStackTrace();\n            int code = HttpServletResponse.SC_BAD_REQUEST;\n            if(t instanceof DapException) {\n                DapException e = (DapException) t;\n                code = e.getCode();\n                if(code <= 0)\n                    code = DapCodes.SC_BAD_REQUEST;\n                e.setCode(code);\n            } else if(t instanceof FileNotFoundException)\n                code = DapCodes.SC_NOT_FOUND;\n            else if(t instanceof UnsupportedOperationException)\n                code = DapCodes.SC_FORBIDDEN;\n            else if(t instanceof MalformedURLException)\n                code = DapCodes.SC_NOT_FOUND;\n            else if(t instanceof IOException)\n                code = DapCodes.SC_BAD_REQUEST;\n            else\n                code = DapCodes.SC_INTERNAL_SERVER_ERROR;\n            senderror(daprequest, code, t);\n        }//catch\n    }", "code_tokens": ["public", "void", "handleRequest", "(", "HttpServletRequest", "req", ",", "HttpServletResponse", "res", ")", "throws", "IOException", "{", "DapLog", ".", "debug", "(", "\"doGet(): User-Agent = \"", "+", "req", ".", "getHeader", "(", "\"User-Agent\"", ")", ")", ";", "if", "(", "!", "this", ".", "initialized", ")", "initialize", "(", ")", ";", "DapRequest", "daprequest", "=", "getRequestState", "(", "req", ",", "res", ")", ";", "String", "url", "=", "daprequest", ".", "getOriginalURL", "(", ")", ";", "StringBuilder", "info", "=", "new", "StringBuilder", "(", "\"doGet():\"", ")", ";", "info", ".", "append", "(", "\" dataset = \"", ")", ";", "info", ".", "append", "(", "\" url = \"", ")", ";", "info", ".", "append", "(", "url", ")", ";", "if", "(", "DEBUG", ")", "{", "System", ".", "err", ".", "println", "(", "\"DAP4 Servlet: processing url: \"", "+", "daprequest", ".", "getOriginalURL", "(", ")", ")", ";", "}", "DapContext", "dapcxt", "=", "new", "DapContext", "(", ")", ";", "// Add entries to the context", "dapcxt", ".", "put", "(", "HttpServletRequest", ".", "class", ",", "req", ")", ";", "dapcxt", ".", "put", "(", "HttpServletResponse", ".", "class", ",", "res", ")", ";", "dapcxt", ".", "put", "(", "DapRequest", ".", "class", ",", "daprequest", ")", ";", "ByteOrder", "order", "=", "daprequest", ".", "getOrder", "(", ")", ";", "ChecksumMode", "checksummode", "=", "daprequest", ".", "getChecksumMode", "(", ")", ";", "dapcxt", ".", "put", "(", "Dap4Util", ".", "DAP4ENDIANTAG", ",", "order", ")", ";", "dapcxt", ".", "put", "(", "Dap4Util", ".", "DAP4CSUMTAG", ",", "checksummode", ")", ";", "// Transfer all other queries", "Map", "<", "String", ",", "String", ">", "queries", "=", "daprequest", ".", "getQueries", "(", ")", ";", "for", "(", "Map", ".", "Entry", "<", "String", ",", "String", ">", "entry", ":", "queries", ".", "entrySet", "(", ")", ")", "{", "if", "(", "dapcxt", ".", "get", "(", "entry", ".", "getKey", "(", ")", ")", "==", "null", ")", "{", "dapcxt", ".", "put", "(", "entry", ".", "getKey", "(", ")", ",", "entry", ".", "getValue", "(", ")", ")", ";", "}", "}", "if", "(", "url", ".", "endsWith", "(", "FAVICON", ")", ")", "{", "doFavicon", "(", "FAVICON", ",", "dapcxt", ")", ";", "return", ";", "}", "String", "datasetpath", "=", "DapUtil", ".", "nullify", "(", "DapUtil", ".", "canonicalpath", "(", "daprequest", ".", "getDataset", "(", ")", ")", ")", ";", "try", "{", "if", "(", "datasetpath", "==", "null", ")", "{", "// This is the case where a request was made without a dataset;", "// According to the spec, I think we should return the", "// services/capabilities document", "doCapabilities", "(", "daprequest", ",", "dapcxt", ")", ";", "}", "else", "{", "RequestMode", "mode", "=", "daprequest", ".", "getMode", "(", ")", ";", "if", "(", "mode", "==", "null", ")", "throw", "new", "DapException", "(", "\"Unrecognized request extension\"", ")", ".", "setCode", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "switch", "(", "mode", ")", "{", "case", "DMR", ":", "doDMR", "(", "daprequest", ",", "dapcxt", ")", ";", "break", ";", "case", "DAP", ":", "doData", "(", "daprequest", ",", "dapcxt", ")", ";", "break", ";", "case", "DSR", ":", "doDSR", "(", "daprequest", ",", "dapcxt", ")", ";", "break", ";", "default", ":", "throw", "new", "DapException", "(", "\"Unrecognized request extension\"", ")", ".", "setCode", "(", "HttpServletResponse", ".", "SC_BAD_REQUEST", ")", ";", "}", "}", "}", "catch", "(", "Throwable", "t", ")", "{", "t", ".", "printStackTrace", "(", ")", ";", "int", "code", "=", "HttpServletResponse", ".", "SC_BAD_REQUEST", ";", "if", "(", "t", "instanceof", "DapException", ")", "{", "DapException", "e", "=", "(", "DapException", ")", "t", ";", "code", "=", "e", ".", "getCode", "(", ")", ";", "if", "(", "code", "<=", "0", ")", "code", "=", "DapCodes", ".", "SC_BAD_REQUEST", ";", "e", ".", "setCode", "(", "code", ")", ";", "}", "else", "if", "(", "t", "instanceof", "FileNotFoundException", ")", "code", "=", "DapCodes", ".", "SC_NOT_FOUND", ";", "else", "if", "(", "t", "instanceof", "UnsupportedOperationException", ")", "code", "=", "DapCodes", ".", "SC_FORBIDDEN", ";", "else", "if", "(", "t", "instanceof", "MalformedURLException", ")", "code", "=", "DapCodes", ".", "SC_NOT_FOUND", ";", "else", "if", "(", "t", "instanceof", "IOException", ")", "code", "=", "DapCodes", ".", "SC_BAD_REQUEST", ";", "else", "code", "=", "DapCodes", ".", "SC_INTERNAL_SERVER_ERROR", ";", "senderror", "(", "daprequest", ",", "code", ",", "t", ")", ";", "}", "//catch", "}"], "docstring": "Primary Controller Entry Point", "docstring_tokens": ["Primary", "Controller", "Entry", "Point"], "sha": "d2d68f9eee87f345625211324d71d5dc3e162ee1", "url": "https://github.com/Unidata/thredds/blob/d2d68f9eee87f345625211324d71d5dc3e162ee1/dap4/d4servlet/src/main/java/dap4/servlet/DapController.java#L178-L264", "partition": "test", "cyclomatic_complexity": 18}, {"repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/util/cache/FileCacheARC.java", "func_name": "FileCacheARC.acquire", "original_string": "@Override\n  public FileCacheable acquire(FileFactory factory, Object hashKey, DatasetUrl location,\n                               int buffer_size, CancelTask cancelTask, Object spiObject) throws IOException {\n\n    if (null == hashKey) hashKey = location.trueurl;\n    if (null == hashKey) throw new IllegalArgumentException();\n\n    Tracker t = null;\n    if (trackAll) {\n      t = new Tracker(hashKey);\n      Tracker prev = track.putIfAbsent(hashKey, t);\n      if (prev != null) t = prev;\n    }\n\n    FileCacheable ncfile = acquireCacheOnly(hashKey);\n    if (ncfile != null) {\n      hits.incrementAndGet();\n      if (t != null) t.hit++;\n      return ncfile;\n    }\n    miss.incrementAndGet();\n    if (t != null) t.miss++;\n\n    // open the file\n    ncfile = factory.open(location, buffer_size, cancelTask, spiObject);\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"FileCacheARC \" + name + \" acquire \" + hashKey + \" \" + ncfile.getLocation());\n    if (debugPrint) System.out.println(\"  FileCacheARC \" + name + \" acquire \" + hashKey + \" \" + ncfile.getLocation());\n\n    // user may have canceled\n    if ((cancelTask != null) && (cancelTask.isCancel())) {\n      if (ncfile != null) ncfile.close();\n      return null;\n    }\n\n    if (disabled.get()) return ncfile;\n\n    addToCache(hashKey, ncfile);\n\n    return ncfile;\n  }", "language": "java", "code": "@Override\n  public FileCacheable acquire(FileFactory factory, Object hashKey, DatasetUrl location,\n                               int buffer_size, CancelTask cancelTask, Object spiObject) throws IOException {\n\n    if (null == hashKey) hashKey = location.trueurl;\n    if (null == hashKey) throw new IllegalArgumentException();\n\n    Tracker t = null;\n    if (trackAll) {\n      t = new Tracker(hashKey);\n      Tracker prev = track.putIfAbsent(hashKey, t);\n      if (prev != null) t = prev;\n    }\n\n    FileCacheable ncfile = acquireCacheOnly(hashKey);\n    if (ncfile != null) {\n      hits.incrementAndGet();\n      if (t != null) t.hit++;\n      return ncfile;\n    }\n    miss.incrementAndGet();\n    if (t != null) t.miss++;\n\n    // open the file\n    ncfile = factory.open(location, buffer_size, cancelTask, spiObject);\n    if (cacheLog.isDebugEnabled())\n      cacheLog.debug(\"FileCacheARC \" + name + \" acquire \" + hashKey + \" \" + ncfile.getLocation());\n    if (debugPrint) System.out.println(\"  FileCacheARC \" + name + \" acquire \" + hashKey + \" \" + ncfile.getLocation());\n\n    // user may have canceled\n    if ((cancelTask != null) && (cancelTask.isCancel())) {\n      if (ncfile != null) ncfile.close();\n      return null;\n    }\n\n    if (disabled.get()) return ncfile;\n\n    addToCache(hashKey, ncfile);\n\n    return ncfile;\n  }", "code_tokens": ["@", "Override", "public", "FileCacheable", "acquire", "(", "FileFactory", "factory", ",", "Object", "hashKey", ",", "DatasetUrl", "location", ",", "int", "buffer_size", ",", "CancelTask", "cancelTask", ",", "Object", "spiObject", ")", "throws", "IOException", "{", "if", "(", "null", "==", "hashKey", ")", "hashKey", "=", "location", ".", "trueurl", ";", "if", "(", "null", "==", "hashKey", ")", "throw", "new", "IllegalArgumentException", "(", ")", ";", "Tracker", "t", "=", "null", ";", "if", "(", "trackAll", ")", "{", "t", "=", "new", "Tracker", "(", "hashKey", ")", ";", "Tracker", "prev", "=", "track", ".", "putIfAbsent", "(", "hashKey", ",", "t", ")", ";", "if", "(", "prev", "!=", "null", ")", "t", "=", "prev", ";", "}", "FileCacheable", "ncfile", "=", "acquireCacheOnly", "(", "hashKey", ")", ";", "if", "(", "ncfile", "!=", "null", ")", "{", "hits", ".", "incrementAndGet", "(", ")", ";", "if", "(", "t", "!=", "null", ")", "t", ".", "hit", "++", ";", "return", "ncfile", ";", "}", "miss", ".", "incrementAndGet", "(", ")", ";", "if", "(", "t", "!=", "null", ")", "t", ".", "miss", "++", ";", "// open the file", "ncfile", "=", "factory", ".", "open", "(", "location", ",", "buffer_size", ",", "cancelTask", ",", "spiObject", ")", ";", "if", "(", "cacheLog", ".", "isDebugEnabled", "(", ")", ")", "cacheLog", ".", "debug", "(", "\"FileCacheARC \"", "+", "name", "+", "\" acquire \"", "+", "hashKey", "+", "\" \"", "+", "ncfile", ".", "getLocation", "(", ")", ")", ";", "if", "(", "debugPrint", ")", "System", ".", "out", ".", "println", "(", "\"  FileCacheARC \"", "+", "name", "+", "\" acquire \"", "+", "hashKey", "+", "\" \"", "+", "ncfile", ".", "getLocation", "(", ")", ")", ";", "// user may have canceled", "if", "(", "(", "cancelTask", "!=", "null", ")", "&&", "(", "cancelTask", ".", "isCancel", "(", ")", ")", ")", "{", "if", "(", "ncfile", "!=", "null", ")", "ncfile", ".", "close", "(", ")", ";", "return", "null", ";", "}", "if", "(", "disabled", ".", "get", "(", ")", ")", "return", "ncfile", ";", "addToCache", "(", "hashKey", ",", "ncfile", ")", ";", "return", "ncfile", ";", "}"], "docstring": "Acquire a FileCacheable from the cache, and lock it so no one else can use it.\nIf not already in cache, open it with FileFactory, and put in cache.\n<p/>\nCall FileCacheable.close() when done, (rather than FileCacheIF.release() directly) and the file is then released instead of closed.\n<p/>\nIf cache size goes over maxElement, then immediately (actually in 100 msec) schedule a cleanup in a background thread.\nThis means that the cache should never get much larger than maxElement, unless you have them all locked.\n\n@param factory     use this factory to open the file if not in the cache; may not be null\n@param hashKey     unique key for this file. If null, the location will be used\n@param location    file location, may also used as the cache name, will be passed to the NetcdfFileFactory\n@param buffer_size RandomAccessFile buffer size, if <= 0, use default size\n@param cancelTask  user can cancel, ok to be null.\n@param spiObject   sent to iosp.setSpecial() if not null\n@return FileCacheable corresponding to location.\n@throws IOException on error", "docstring_tokens": ["Acquire", "a", "FileCacheable", "from", "the", "cache", "and", "lock", "it", "so", "no", "one", "else", "can", "use", "it", ".", "If", "not", "already", "in", "cache", "open", "it", "with", "FileFactory", "and", "put", "in", "cache", ".", "<p", "/", ">", "Call", "FileCacheable", ".", "close", "()", "when", "done", "(", "rather", "than", "FileCacheIF", ".", "release", "()", "directly", ")", "and", "the", "file", "is", "then", "released", "instead", "of", "closed", ".", "<p", "/", ">", "If", "cache", "size", "goes", "over", "maxElement", "then", "immediately", "(", "actually", "in", "100", "msec", ")", "schedule", "a", "cleanup", "in", "a", "background", "thread", ".", "This", "means", "that", "the", "cache", "should", "never", "get", "much", "larger", "than", "maxElement", "unless", "you", "have", "them", "all", "locked", "."], "sha": "d2d68f9eee87f345625211324d71d5dc3e162ee1", "url": "https://github.com/Unidata/thredds/blob/d2d68f9eee87f345625211324d71d5dc3e162ee1/cdm/src/main/java/ucar/nc2/util/cache/FileCacheARC.java#L129-L169", "partition": "test", "cyclomatic_complexity": 14}, {"repo": "Unidata/thredds", "path": "cdm/src/main/java/ucar/nc2/NCdumpW.java", "func_name": "NCdumpW.print", "original_string": "public static boolean print(NetcdfFile nc, String command, Writer out, ucar.nc2.util.CancelTask ct)\n          throws IOException {\n    WantValues showValues = WantValues.none;\n    boolean ncml = false;\n    boolean strict = false;\n    String varNames = null;\n    String trueDataset = null;\n    String fakeDataset = null;\n\n    if (command != null) {\n      StringTokenizer stoke = new StringTokenizer(command);\n\n      while (stoke.hasMoreTokens()) {\n        String toke = stoke.nextToken();\n        if (toke.equalsIgnoreCase(\"-help\")) {\n          out.write(usage);\n          out.write('\\n');\n          return true;\n        }\n        if (toke.equalsIgnoreCase(\"-vall\"))\n          showValues = WantValues.all;\n        if (toke.equalsIgnoreCase(\"-c\") && (showValues == WantValues.none))\n          showValues = WantValues.coordsOnly;\n        if (toke.equalsIgnoreCase(\"-ncml\"))\n          ncml = true;\n        if (toke.equalsIgnoreCase(\"-cdl\") || toke.equalsIgnoreCase(\"-strict\"))\n          strict = true;\n        if(toke.equalsIgnoreCase(\"-v\") && stoke.hasMoreTokens())\n          varNames = stoke.nextToken();\n        if (toke.equalsIgnoreCase(\"-datasetname\") && stoke.hasMoreTokens()) {\n          fakeDataset = stoke.nextToken();\n          if(fakeDataset.length() == 0) fakeDataset = null;\n          if(fakeDataset != null) {\n            trueDataset = nc.getLocation();\n            nc.setLocation(fakeDataset);\n          }\n        }\n      }\n    }\n\n    boolean ok = print(nc, out, showValues, ncml, strict, varNames, ct);\n    if(trueDataset != null && fakeDataset != null)\n      nc.setLocation(trueDataset);\n    return ok;\n  }", "language": "java", "code": "public static boolean print(NetcdfFile nc, String command, Writer out, ucar.nc2.util.CancelTask ct)\n          throws IOException {\n    WantValues showValues = WantValues.none;\n    boolean ncml = false;\n    boolean strict = false;\n    String varNames = null;\n    String trueDataset = null;\n    String fakeDataset = null;\n\n    if (command != null) {\n      StringTokenizer stoke = new StringTokenizer(command);\n\n      while (stoke.hasMoreTokens()) {\n        String toke = stoke.nextToken();\n        if (toke.equalsIgnoreCase(\"-help\")) {\n          out.write(usage);\n          out.write('\\n');\n          return true;\n        }\n        if (toke.equalsIgnoreCase(\"-vall\"))\n          showValues = WantValues.all;\n        if (toke.equalsIgnoreCase(\"-c\") && (showValues == WantValues.none))\n          showValues = WantValues.coordsOnly;\n        if (toke.equalsIgnoreCase(\"-ncml\"))\n          ncml = true;\n        if (toke.equalsIgnoreCase(\"-cdl\") || toke.equalsIgnoreCase(\"-strict\"))\n          strict = true;\n        if(toke.equalsIgnoreCase(\"-v\") && stoke.hasMoreTokens())\n          varNames = stoke.nextToken();\n        if (toke.equalsIgnoreCase(\"-datasetname\") && stoke.hasMoreTokens()) {\n          fakeDataset = stoke.nextToken();\n          if(fakeDataset.length() == 0) fakeDataset = null;\n          if(fakeDataset != null) {\n            trueDataset = nc.getLocation();\n            nc.setLocation(fakeDataset);\n          }\n        }\n      }\n    }\n\n    boolean ok = print(nc, out, showValues, ncml, strict, varNames, ct);\n    if(trueDataset != null && fakeDataset != null)\n      nc.setLocation(trueDataset);\n    return ok;\n  }", "code_tokens": ["public", "static", "boolean", "print", "(", "NetcdfFile", "nc", ",", "String", "command", ",", "Writer", "out", ",", "ucar", ".", "nc2", ".", "util", ".", "CancelTask", "ct", ")", "throws", "IOException", "{", "WantValues", "showValues", "=", "WantValues", ".", "none", ";", "boolean", "ncml", "=", "false", ";", "boolean", "strict", "=", "false", ";", "String", "varNames", "=", "null", ";", "String", "trueDataset", "=", "null", ";", "String", "fakeDataset", "=", "null", ";", "if", "(", "command", "!=", "null", ")", "{", "StringTokenizer", "stoke", "=", "new", "StringTokenizer", "(", "command", ")", ";", "while", "(", "stoke", ".", "hasMoreTokens", "(", ")", ")", "{", "String", "toke", "=", "stoke", ".", "nextToken", "(", ")", ";", "if", "(", "toke", ".", "equalsIgnoreCase", "(", "\"-help\"", ")", ")", "{", "out", ".", "write", "(", "usage", ")", ";", "out", ".", "write", "(", "'", "'", ")", ";", "return", "true", ";", "}", "if", "(", "toke", ".", "equalsIgnoreCase", "(", "\"-vall\"", ")", ")", "showValues", "=", "WantValues", ".", "all", ";", "if", "(", "toke", ".", "equalsIgnoreCase", "(", "\"-c\"", ")", "&&", "(", "showValues", "==", "WantValues", ".", "none", ")", ")", "showValues", "=", "WantValues", ".", "coordsOnly", ";", "if", "(", "toke", ".", "equalsIgnoreCase", "(", "\"-ncml\"", ")", ")", "ncml", "=", "true", ";", "if", "(", "toke", ".", "equalsIgnoreCase", "(", "\"-cdl\"", ")", "||", "toke", ".", "equalsIgnoreCase", "(", "\"-strict\"", ")", ")", "strict", "=", "true", ";", "if", "(", "toke", ".", "equalsIgnoreCase", "(", "\"-v\"", ")", "&&", "stoke", ".", "hasMoreTokens", "(", ")", ")", "varNames", "=", "stoke", ".", "nextToken", "(", ")", ";", "if", "(", "toke", ".", "equalsIgnoreCase", "(", "\"-datasetname\"", ")", "&&", "stoke", ".", "hasMoreTokens", "(", ")", ")", "{", "fakeDataset", "=", "stoke", ".", "nextToken", "(", ")", ";", "if", "(", "fakeDataset", ".", "length", "(", ")", "==", "0", ")", "fakeDataset", "=", "null", ";", "if", "(", "fakeDataset", "!=", "null", ")", "{", "trueDataset", "=", "nc", ".", "getLocation", "(", ")", ";", "nc", ".", "setLocation", "(", "fakeDataset", ")", ";", "}", "}", "}", "}", "boolean", "ok", "=", "print", "(", "nc", ",", "out", ",", "showValues", ",", "ncml", ",", "strict", ",", "varNames", ",", "ct", ")", ";", "if", "(", "trueDataset", "!=", "null", "&&", "fakeDataset", "!=", "null", ")", "nc", ".", "setLocation", "(", "trueDataset", ")", ";", "return", "ok", ";", "}"], "docstring": "ncdump, parsing command string, file already open.\n\n@param nc      apply command to this file\n@param command : command string\n@param out     send output here\n@param ct      allow task to be cancelled; may be null.\n@return true if successful\n@throws IOException on write error", "docstring_tokens": ["ncdump", "parsing", "command", "string", "file", "already", "open", "."], "sha": "d2d68f9eee87f345625211324d71d5dc3e162ee1", "url": "https://github.com/Unidata/thredds/blob/d2d68f9eee87f345625211324d71d5dc3e162ee1/cdm/src/main/java/ucar/nc2/NCdumpW.java#L89-L133", "partition": "test", "cyclomatic_complexity": 18}]}