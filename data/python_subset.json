{"samples": [{"repo": "chrisjrn/registrasion", "path": "registrasion/reporting/views.py", "func_name": "attendee", "original_string": "def attendee(request, form, user_id=None):\n    ''' Returns a list of all manifested attendees if no attendee is specified,\n    else displays the attendee manifest. '''\n\n    if user_id is None and form.cleaned_data[\"user\"] is not None:\n        user_id = form.cleaned_data[\"user\"]\n\n    if user_id is None:\n        return attendee_list(request)\n\n    attendee = people.Attendee.objects.get(user__id=user_id)\n    name = attendee.attendeeprofilebase.attendee_name()\n\n    reports = []\n\n    profile_data = []\n    try:\n        profile = people.AttendeeProfileBase.objects.get_subclass(\n            attendee=attendee\n        )\n        fields = profile._meta.get_fields()\n    except people.AttendeeProfileBase.DoesNotExist:\n        fields = []\n\n    exclude = set([\"attendeeprofilebase_ptr\", \"id\"])\n    for field in fields:\n        if field.name in exclude:\n            # Not actually important\n            continue\n        if not hasattr(field, \"verbose_name\"):\n            continue  # Not a publicly visible field\n        value = getattr(profile, field.name)\n\n        if isinstance(field, models.ManyToManyField):\n            value = \", \".join(str(i) for i in value.all())\n\n        profile_data.append((field.verbose_name, value))\n\n    cart = CartController.for_user(attendee.user)\n    reservation = cart.cart.reservation_duration + cart.cart.time_last_updated\n    profile_data.append((\"Current cart reserved until\", reservation))\n\n    reports.append(ListReport(\"Profile\", [\"\", \"\"], profile_data))\n\n    links = []\n    links.append((\n        reverse(views.badge, args=[user_id]),\n        \"View badge\",\n    ))\n    links.append((\n        reverse(views.amend_registration, args=[user_id]),\n        \"Amend current cart\",\n    ))\n    links.append((\n        reverse(views.extend_reservation, args=[user_id]),\n        \"Extend reservation\",\n    ))\n\n    reports.append(Links(\"Actions for \" + name, links))\n\n    # Paid and pending  products\n    ic = ItemController(attendee.user)\n    reports.append(ListReport(\n        \"Paid Products\",\n        [\"Product\", \"Quantity\"],\n        [(pq.product, pq.quantity) for pq in ic.items_purchased()],\n    ))\n    reports.append(ListReport(\n        \"Unpaid Products\",\n        [\"Product\", \"Quantity\"],\n        [(pq.product, pq.quantity) for pq in ic.items_pending()],\n    ))\n\n    # Invoices\n    invoices = commerce.Invoice.objects.filter(\n        user=attendee.user,\n    )\n    reports.append(QuerysetReport(\n        \"Invoices\",\n        [\"id\", \"get_status_display\", \"value\"],\n        invoices,\n        headings=[\"Invoice ID\", \"Status\", \"Value\"],\n        link_view=views.invoice,\n    ))\n\n    # Credit Notes\n    credit_notes = commerce.CreditNote.objects.filter(\n        invoice__user=attendee.user,\n    ).select_related(\"invoice\", \"creditnoteapplication\", \"creditnoterefund\")\n\n    reports.append(QuerysetReport(\n        \"Credit Notes\",\n        [\"id\", \"status\", \"value\"],\n        credit_notes,\n        link_view=views.credit_note,\n    ))\n\n    # All payments\n    payments = commerce.PaymentBase.objects.filter(\n        invoice__user=attendee.user,\n    ).select_related(\"invoice\")\n\n    reports.append(QuerysetReport(\n        \"Payments\",\n        [\"invoice__id\", \"id\", \"reference\", \"amount\"],\n        payments,\n        link_view=views.invoice,\n    ))\n\n    return reports", "language": "python", "code": "def attendee(request, form, user_id=None):\n    ''' Returns a list of all manifested attendees if no attendee is specified,\n    else displays the attendee manifest. '''\n\n    if user_id is None and form.cleaned_data[\"user\"] is not None:\n        user_id = form.cleaned_data[\"user\"]\n\n    if user_id is None:\n        return attendee_list(request)\n\n    attendee = people.Attendee.objects.get(user__id=user_id)\n    name = attendee.attendeeprofilebase.attendee_name()\n\n    reports = []\n\n    profile_data = []\n    try:\n        profile = people.AttendeeProfileBase.objects.get_subclass(\n            attendee=attendee\n        )\n        fields = profile._meta.get_fields()\n    except people.AttendeeProfileBase.DoesNotExist:\n        fields = []\n\n    exclude = set([\"attendeeprofilebase_ptr\", \"id\"])\n    for field in fields:\n        if field.name in exclude:\n            # Not actually important\n            continue\n        if not hasattr(field, \"verbose_name\"):\n            continue  # Not a publicly visible field\n        value = getattr(profile, field.name)\n\n        if isinstance(field, models.ManyToManyField):\n            value = \", \".join(str(i) for i in value.all())\n\n        profile_data.append((field.verbose_name, value))\n\n    cart = CartController.for_user(attendee.user)\n    reservation = cart.cart.reservation_duration + cart.cart.time_last_updated\n    profile_data.append((\"Current cart reserved until\", reservation))\n\n    reports.append(ListReport(\"Profile\", [\"\", \"\"], profile_data))\n\n    links = []\n    links.append((\n        reverse(views.badge, args=[user_id]),\n        \"View badge\",\n    ))\n    links.append((\n        reverse(views.amend_registration, args=[user_id]),\n        \"Amend current cart\",\n    ))\n    links.append((\n        reverse(views.extend_reservation, args=[user_id]),\n        \"Extend reservation\",\n    ))\n\n    reports.append(Links(\"Actions for \" + name, links))\n\n    # Paid and pending  products\n    ic = ItemController(attendee.user)\n    reports.append(ListReport(\n        \"Paid Products\",\n        [\"Product\", \"Quantity\"],\n        [(pq.product, pq.quantity) for pq in ic.items_purchased()],\n    ))\n    reports.append(ListReport(\n        \"Unpaid Products\",\n        [\"Product\", \"Quantity\"],\n        [(pq.product, pq.quantity) for pq in ic.items_pending()],\n    ))\n\n    # Invoices\n    invoices = commerce.Invoice.objects.filter(\n        user=attendee.user,\n    )\n    reports.append(QuerysetReport(\n        \"Invoices\",\n        [\"id\", \"get_status_display\", \"value\"],\n        invoices,\n        headings=[\"Invoice ID\", \"Status\", \"Value\"],\n        link_view=views.invoice,\n    ))\n\n    # Credit Notes\n    credit_notes = commerce.CreditNote.objects.filter(\n        invoice__user=attendee.user,\n    ).select_related(\"invoice\", \"creditnoteapplication\", \"creditnoterefund\")\n\n    reports.append(QuerysetReport(\n        \"Credit Notes\",\n        [\"id\", \"status\", \"value\"],\n        credit_notes,\n        link_view=views.credit_note,\n    ))\n\n    # All payments\n    payments = commerce.PaymentBase.objects.filter(\n        invoice__user=attendee.user,\n    ).select_related(\"invoice\")\n\n    reports.append(QuerysetReport(\n        \"Payments\",\n        [\"invoice__id\", \"id\", \"reference\", \"amount\"],\n        payments,\n        link_view=views.invoice,\n    ))\n\n    return reports", "code_tokens": ["def", "attendee", "(", "request", ",", "form", ",", "user_id", "=", "None", ")", ":", "if", "user_id", "is", "None", "and", "form", ".", "cleaned_data", "[", "\"user\"", "]", "is", "not", "None", ":", "user_id", "=", "form", ".", "cleaned_data", "[", "\"user\"", "]", "if", "user_id", "is", "None", ":", "return", "attendee_list", "(", "request", ")", "attendee", "=", "people", ".", "Attendee", ".", "objects", ".", "get", "(", "user__id", "=", "user_id", ")", "name", "=", "attendee", ".", "attendeeprofilebase", ".", "attendee_name", "(", ")", "reports", "=", "[", "]", "profile_data", "=", "[", "]", "try", ":", "profile", "=", "people", ".", "AttendeeProfileBase", ".", "objects", ".", "get_subclass", "(", "attendee", "=", "attendee", ")", "fields", "=", "profile", ".", "_meta", ".", "get_fields", "(", ")", "except", "people", ".", "AttendeeProfileBase", ".", "DoesNotExist", ":", "fields", "=", "[", "]", "exclude", "=", "set", "(", "[", "\"attendeeprofilebase_ptr\"", ",", "\"id\"", "]", ")", "for", "field", "in", "fields", ":", "if", "field", ".", "name", "in", "exclude", ":", "# Not actually important", "continue", "if", "not", "hasattr", "(", "field", ",", "\"verbose_name\"", ")", ":", "continue", "# Not a publicly visible field", "value", "=", "getattr", "(", "profile", ",", "field", ".", "name", ")", "if", "isinstance", "(", "field", ",", "models", ".", "ManyToManyField", ")", ":", "value", "=", "\", \"", ".", "join", "(", "str", "(", "i", ")", "for", "i", "in", "value", ".", "all", "(", ")", ")", "profile_data", ".", "append", "(", "(", "field", ".", "verbose_name", ",", "value", ")", ")", "cart", "=", "CartController", ".", "for_user", "(", "attendee", ".", "user", ")", "reservation", "=", "cart", ".", "cart", ".", "reservation_duration", "+", "cart", ".", "cart", ".", "time_last_updated", "profile_data", ".", "append", "(", "(", "\"Current cart reserved until\"", ",", "reservation", ")", ")", "reports", ".", "append", "(", "ListReport", "(", "\"Profile\"", ",", "[", "\"\"", ",", "\"\"", "]", ",", "profile_data", ")", ")", "links", "=", "[", "]", "links", ".", "append", "(", "(", "reverse", "(", "views", ".", "badge", ",", "args", "=", "[", "user_id", "]", ")", ",", "\"View badge\"", ",", ")", ")", "links", ".", "append", "(", "(", "reverse", "(", "views", ".", "amend_registration", ",", "args", "=", "[", "user_id", "]", ")", ",", "\"Amend current cart\"", ",", ")", ")", "links", ".", "append", "(", "(", "reverse", "(", "views", ".", "extend_reservation", ",", "args", "=", "[", "user_id", "]", ")", ",", "\"Extend reservation\"", ",", ")", ")", "reports", ".", "append", "(", "Links", "(", "\"Actions for \"", "+", "name", ",", "links", ")", ")", "# Paid and pending  products", "ic", "=", "ItemController", "(", "attendee", ".", "user", ")", "reports", ".", "append", "(", "ListReport", "(", "\"Paid Products\"", ",", "[", "\"Product\"", ",", "\"Quantity\"", "]", ",", "[", "(", "pq", ".", "product", ",", "pq", ".", "quantity", ")", "for", "pq", "in", "ic", ".", "items_purchased", "(", ")", "]", ",", ")", ")", "reports", ".", "append", "(", "ListReport", "(", "\"Unpaid Products\"", ",", "[", "\"Product\"", ",", "\"Quantity\"", "]", ",", "[", "(", "pq", ".", "product", ",", "pq", ".", "quantity", ")", "for", "pq", "in", "ic", ".", "items_pending", "(", ")", "]", ",", ")", ")", "# Invoices", "invoices", "=", "commerce", ".", "Invoice", ".", "objects", ".", "filter", "(", "user", "=", "attendee", ".", "user", ",", ")", "reports", ".", "append", "(", "QuerysetReport", "(", "\"Invoices\"", ",", "[", "\"id\"", ",", "\"get_status_display\"", ",", "\"value\"", "]", ",", "invoices", ",", "headings", "=", "[", "\"Invoice ID\"", ",", "\"Status\"", ",", "\"Value\"", "]", ",", "link_view", "=", "views", ".", "invoice", ",", ")", ")", "# Credit Notes", "credit_notes", "=", "commerce", ".", "CreditNote", ".", "objects", ".", "filter", "(", "invoice__user", "=", "attendee", ".", "user", ",", ")", ".", "select_related", "(", "\"invoice\"", ",", "\"creditnoteapplication\"", ",", "\"creditnoterefund\"", ")", "reports", ".", "append", "(", "QuerysetReport", "(", "\"Credit Notes\"", ",", "[", "\"id\"", ",", "\"status\"", ",", "\"value\"", "]", ",", "credit_notes", ",", "link_view", "=", "views", ".", "credit_note", ",", ")", ")", "# All payments", "payments", "=", "commerce", ".", "PaymentBase", ".", "objects", ".", "filter", "(", "invoice__user", "=", "attendee", ".", "user", ",", ")", ".", "select_related", "(", "\"invoice\"", ")", "reports", ".", "append", "(", "QuerysetReport", "(", "\"Payments\"", ",", "[", "\"invoice__id\"", ",", "\"id\"", ",", "\"reference\"", ",", "\"amount\"", "]", ",", "payments", ",", "link_view", "=", "views", ".", "invoice", ",", ")", ")", "return", "reports"], "docstring": "Returns a list of all manifested attendees if no attendee is specified,\n    else displays the attendee manifest.", "docstring_tokens": ["Returns", "a", "list", "of", "all", "manifested", "attendees", "if", "no", "attendee", "is", "specified", "else", "displays", "the", "attendee", "manifest", "."], "sha": "461d5846c6f9f3b7099322a94f5d9911564448e4", "url": "https://github.com/chrisjrn/registrasion/blob/461d5846c6f9f3b7099322a94f5d9911564448e4/registrasion/reporting/views.py#L457-L566", "partition": "test", "cyclomatic_complexity": 12}, {"repo": "lkreidberg/batman", "path": "batman/transitmodel.py", "func_name": "TransitModel.light_curve", "original_string": "def light_curve(self, params):\n\t\t\"\"\"\n\t\tCalculate a model light curve.\n\n\t\t:param params: Transit parameters\n\t\t:type params: A `TransitParams` instance\n\n\t\t:return: Relative flux \n\t\t:rtype: ndarray\n\n\t\t:Example:\n\n\t\t>>> flux = m.light_curve(params)\n\t\t\"\"\"\n\t\t#recalculates rsky and fac if necessary\n\t\tif params.t0 != self.t0 or params.per != self.per or params.a != self.a or params.inc != self.inc or params.ecc != self.ecc or params.w != self.w or params.t_secondary != self.t_secondary:\n\t\t\tif self.transittype == 2 and params.t_secondary != self.t_secondary:\n\t\t\t\tparams.t0 = self.get_t_conjunction(params)\n\t\t\tself.ds= _rsky._rsky(self.t_supersample, params.t0, params.per, params.a, params.inc*pi/180., params.ecc, params.w*pi/180., self.transittype, self.nthreads)\n\t\tif params.limb_dark != self.limb_dark: self.fac = self._get_fac()\n\n\t\t#updates transit params\n\t\tself.t0 = params.t0\n\t\tself.per = params.per\n\t\tself.rp = params.rp\n\t\tself.a = params.a\n\t\tself.inc = params.inc\n\t\tself.ecc = params.ecc\n\t\tself.w = params.w\n\t\tself.u = params.u\n\t\tself.limb_dark = params.limb_dark\n\t\tself.fp = params.fp\n\t\tself.t_secondary = params.t_secondary\n\t\tself.inverse = False\n\n\t\t#handles the case of inverse transits (rp < 0)\n\t\tif self.rp < 0.: \n\t\t\tself.rp = -1.*self.rp\n\t\t\tparams.rp = -1.*params.rp\n\t\t\tself.inverse = True\n\t\t\n\t\tif self.transittype == 1:\n\t\t\tif params.limb_dark != self.limb_dark: raise Exception(\"Need to reinitialize model in order to change limb darkening option\")\n\t\t\tif self.limb_dark == \"quadratic\": lc = _quadratic_ld._quadratic_ld(self.ds, params.rp, params.u[0], params.u[1], self.nthreads)\n\t\t\telif self.limb_dark == \"linear\": lc = _quadratic_ld._quadratic_ld(self.ds, params.rp, params.u[0], 0., self.nthreads)\n\t\t\telif self.limb_dark == \"nonlinear\": lc = _nonlinear_ld._nonlinear_ld(self.ds, params.rp, params.u[0], params.u[1], params.u[2], params.u[3], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"squareroot\": lc = _nonlinear_ld._nonlinear_ld(self.ds, params.rp, params.u[1], params.u[0], 0., 0., self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"uniform\": lc = _uniform_ld._uniform_ld(self.ds, params.rp, self.nthreads)\n\t\t\telif self.limb_dark == \"logarithmic\": lc = _logarithmic_ld._logarithmic_ld(self.ds, params.rp, params.u[0], params.u[1], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"exponential\": lc = _exponential_ld._exponential_ld(self.ds, params.rp, params.u[0], params.u[1], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"power2\": lc = _power2_ld._power2_ld(self.ds, params.rp, params.u[0], params.u[1], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"custom\": lc = _custom_ld._custom_ld(self.ds, params.rp, params.u[0], params.u[1], params.u[2], params.u[3], params.u[4], params.u[5], self.fac, self.nthreads)\n\t\t\telse: raise Exception(\"Invalid limb darkening option\")\n\n\t\t\tif self.inverse == True: lc = 2. - lc\n\n\t\telse: lc = _eclipse._eclipse(self.ds, params.rp, params.fp, self.nthreads)\t\t\t\n\t\tif self.supersample_factor == 1: return lc\n\t\telse: return np.mean(lc.reshape(-1, self.supersample_factor), axis=1)", "language": "python", "code": "def light_curve(self, params):\n\t\t\"\"\"\n\t\tCalculate a model light curve.\n\n\t\t:param params: Transit parameters\n\t\t:type params: A `TransitParams` instance\n\n\t\t:return: Relative flux \n\t\t:rtype: ndarray\n\n\t\t:Example:\n\n\t\t>>> flux = m.light_curve(params)\n\t\t\"\"\"\n\t\t#recalculates rsky and fac if necessary\n\t\tif params.t0 != self.t0 or params.per != self.per or params.a != self.a or params.inc != self.inc or params.ecc != self.ecc or params.w != self.w or params.t_secondary != self.t_secondary:\n\t\t\tif self.transittype == 2 and params.t_secondary != self.t_secondary:\n\t\t\t\tparams.t0 = self.get_t_conjunction(params)\n\t\t\tself.ds= _rsky._rsky(self.t_supersample, params.t0, params.per, params.a, params.inc*pi/180., params.ecc, params.w*pi/180., self.transittype, self.nthreads)\n\t\tif params.limb_dark != self.limb_dark: self.fac = self._get_fac()\n\n\t\t#updates transit params\n\t\tself.t0 = params.t0\n\t\tself.per = params.per\n\t\tself.rp = params.rp\n\t\tself.a = params.a\n\t\tself.inc = params.inc\n\t\tself.ecc = params.ecc\n\t\tself.w = params.w\n\t\tself.u = params.u\n\t\tself.limb_dark = params.limb_dark\n\t\tself.fp = params.fp\n\t\tself.t_secondary = params.t_secondary\n\t\tself.inverse = False\n\n\t\t#handles the case of inverse transits (rp < 0)\n\t\tif self.rp < 0.: \n\t\t\tself.rp = -1.*self.rp\n\t\t\tparams.rp = -1.*params.rp\n\t\t\tself.inverse = True\n\t\t\n\t\tif self.transittype == 1:\n\t\t\tif params.limb_dark != self.limb_dark: raise Exception(\"Need to reinitialize model in order to change limb darkening option\")\n\t\t\tif self.limb_dark == \"quadratic\": lc = _quadratic_ld._quadratic_ld(self.ds, params.rp, params.u[0], params.u[1], self.nthreads)\n\t\t\telif self.limb_dark == \"linear\": lc = _quadratic_ld._quadratic_ld(self.ds, params.rp, params.u[0], 0., self.nthreads)\n\t\t\telif self.limb_dark == \"nonlinear\": lc = _nonlinear_ld._nonlinear_ld(self.ds, params.rp, params.u[0], params.u[1], params.u[2], params.u[3], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"squareroot\": lc = _nonlinear_ld._nonlinear_ld(self.ds, params.rp, params.u[1], params.u[0], 0., 0., self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"uniform\": lc = _uniform_ld._uniform_ld(self.ds, params.rp, self.nthreads)\n\t\t\telif self.limb_dark == \"logarithmic\": lc = _logarithmic_ld._logarithmic_ld(self.ds, params.rp, params.u[0], params.u[1], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"exponential\": lc = _exponential_ld._exponential_ld(self.ds, params.rp, params.u[0], params.u[1], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"power2\": lc = _power2_ld._power2_ld(self.ds, params.rp, params.u[0], params.u[1], self.fac, self.nthreads)\n\t\t\telif self.limb_dark == \"custom\": lc = _custom_ld._custom_ld(self.ds, params.rp, params.u[0], params.u[1], params.u[2], params.u[3], params.u[4], params.u[5], self.fac, self.nthreads)\n\t\t\telse: raise Exception(\"Invalid limb darkening option\")\n\n\t\t\tif self.inverse == True: lc = 2. - lc\n\n\t\telse: lc = _eclipse._eclipse(self.ds, params.rp, params.fp, self.nthreads)\t\t\t\n\t\tif self.supersample_factor == 1: return lc\n\t\telse: return np.mean(lc.reshape(-1, self.supersample_factor), axis=1)", "code_tokens": ["def", "light_curve", "(", "self", ",", "params", ")", ":", "#recalculates rsky and fac if necessary", "if", "params", ".", "t0", "!=", "self", ".", "t0", "or", "params", ".", "per", "!=", "self", ".", "per", "or", "params", ".", "a", "!=", "self", ".", "a", "or", "params", ".", "inc", "!=", "self", ".", "inc", "or", "params", ".", "ecc", "!=", "self", ".", "ecc", "or", "params", ".", "w", "!=", "self", ".", "w", "or", "params", ".", "t_secondary", "!=", "self", ".", "t_secondary", ":", "if", "self", ".", "transittype", "==", "2", "and", "params", ".", "t_secondary", "!=", "self", ".", "t_secondary", ":", "params", ".", "t0", "=", "self", ".", "get_t_conjunction", "(", "params", ")", "self", ".", "ds", "=", "_rsky", ".", "_rsky", "(", "self", ".", "t_supersample", ",", "params", ".", "t0", ",", "params", ".", "per", ",", "params", ".", "a", ",", "params", ".", "inc", "*", "pi", "/", "180.", ",", "params", ".", "ecc", ",", "params", ".", "w", "*", "pi", "/", "180.", ",", "self", ".", "transittype", ",", "self", ".", "nthreads", ")", "if", "params", ".", "limb_dark", "!=", "self", ".", "limb_dark", ":", "self", ".", "fac", "=", "self", ".", "_get_fac", "(", ")", "#updates transit params", "self", ".", "t0", "=", "params", ".", "t0", "self", ".", "per", "=", "params", ".", "per", "self", ".", "rp", "=", "params", ".", "rp", "self", ".", "a", "=", "params", ".", "a", "self", ".", "inc", "=", "params", ".", "inc", "self", ".", "ecc", "=", "params", ".", "ecc", "self", ".", "w", "=", "params", ".", "w", "self", ".", "u", "=", "params", ".", "u", "self", ".", "limb_dark", "=", "params", ".", "limb_dark", "self", ".", "fp", "=", "params", ".", "fp", "self", ".", "t_secondary", "=", "params", ".", "t_secondary", "self", ".", "inverse", "=", "False", "#handles the case of inverse transits (rp < 0)", "if", "self", ".", "rp", "<", "0.", ":", "self", ".", "rp", "=", "-", "1.", "*", "self", ".", "rp", "params", ".", "rp", "=", "-", "1.", "*", "params", ".", "rp", "self", ".", "inverse", "=", "True", "if", "self", ".", "transittype", "==", "1", ":", "if", "params", ".", "limb_dark", "!=", "self", ".", "limb_dark", ":", "raise", "Exception", "(", "\"Need to reinitialize model in order to change limb darkening option\"", ")", "if", "self", ".", "limb_dark", "==", "\"quadratic\"", ":", "lc", "=", "_quadratic_ld", ".", "_quadratic_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "0", "]", ",", "params", ".", "u", "[", "1", "]", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"linear\"", ":", "lc", "=", "_quadratic_ld", ".", "_quadratic_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "0", "]", ",", "0.", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"nonlinear\"", ":", "lc", "=", "_nonlinear_ld", ".", "_nonlinear_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "0", "]", ",", "params", ".", "u", "[", "1", "]", ",", "params", ".", "u", "[", "2", "]", ",", "params", ".", "u", "[", "3", "]", ",", "self", ".", "fac", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"squareroot\"", ":", "lc", "=", "_nonlinear_ld", ".", "_nonlinear_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "1", "]", ",", "params", ".", "u", "[", "0", "]", ",", "0.", ",", "0.", ",", "self", ".", "fac", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"uniform\"", ":", "lc", "=", "_uniform_ld", ".", "_uniform_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"logarithmic\"", ":", "lc", "=", "_logarithmic_ld", ".", "_logarithmic_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "0", "]", ",", "params", ".", "u", "[", "1", "]", ",", "self", ".", "fac", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"exponential\"", ":", "lc", "=", "_exponential_ld", ".", "_exponential_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "0", "]", ",", "params", ".", "u", "[", "1", "]", ",", "self", ".", "fac", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"power2\"", ":", "lc", "=", "_power2_ld", ".", "_power2_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "0", "]", ",", "params", ".", "u", "[", "1", "]", ",", "self", ".", "fac", ",", "self", ".", "nthreads", ")", "elif", "self", ".", "limb_dark", "==", "\"custom\"", ":", "lc", "=", "_custom_ld", ".", "_custom_ld", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "u", "[", "0", "]", ",", "params", ".", "u", "[", "1", "]", ",", "params", ".", "u", "[", "2", "]", ",", "params", ".", "u", "[", "3", "]", ",", "params", ".", "u", "[", "4", "]", ",", "params", ".", "u", "[", "5", "]", ",", "self", ".", "fac", ",", "self", ".", "nthreads", ")", "else", ":", "raise", "Exception", "(", "\"Invalid limb darkening option\"", ")", "if", "self", ".", "inverse", "==", "True", ":", "lc", "=", "2.", "-", "lc", "else", ":", "lc", "=", "_eclipse", ".", "_eclipse", "(", "self", ".", "ds", ",", "params", ".", "rp", ",", "params", ".", "fp", ",", "self", ".", "nthreads", ")", "if", "self", ".", "supersample_factor", "==", "1", ":", "return", "lc", "else", ":", "return", "np", ".", "mean", "(", "lc", ".", "reshape", "(", "-", "1", ",", "self", ".", "supersample_factor", ")", ",", "axis", "=", "1", ")"], "docstring": "Calculate a model light curve.\n\n\t\t:param params: Transit parameters\n\t\t:type params: A `TransitParams` instance\n\n\t\t:return: Relative flux \n\t\t:rtype: ndarray\n\n\t\t:Example:\n\n\t\t>>> flux = m.light_curve(params)", "docstring_tokens": ["Calculate", "a", "model", "light", "curve", "."], "sha": "77f3275c12a01ef5b7a89b1aeb6272a7c28452a1", "url": "https://github.com/lkreidberg/batman/blob/77f3275c12a01ef5b7a89b1aeb6272a7c28452a1/batman/transitmodel.py#L215-L273", "partition": "test", "cyclomatic_complexity": 25}, {"repo": "jazzband/django-ddp", "path": "dddp/models.py", "func_name": "get_meteor_id", "original_string": "def get_meteor_id(obj_or_model, obj_pk=None):\n    \"\"\"Return an Alea ID for the given object.\"\"\"\n    if obj_or_model is None:\n        return None\n    # Django model._meta is now public API -> pylint: disable=W0212\n    meta = obj_or_model._meta\n    model = meta.model\n    if model is ObjectMapping:\n        # this doesn't make sense - raise TypeError\n        raise TypeError(\"Can't map ObjectMapping instances through self.\")\n\n    # try getting value of AleaIdField straight from instance if possible\n    if isinstance(obj_or_model, model):\n        # obj_or_model is an instance, not a model.\n        if isinstance(meta.pk, AleaIdField):\n            return obj_or_model.pk\n        if obj_pk is None:\n            # fall back to primary key, but coerce as string type for lookup.\n            obj_pk = str(obj_or_model.pk)\n    alea_unique_fields = [\n        field\n        for field in meta.local_fields\n        if isinstance(field, AleaIdField) and field.unique\n    ]\n    if len(alea_unique_fields) == 1:\n        # found an AleaIdField with unique=True, assume it's got the value.\n        aid = alea_unique_fields[0].attname\n        if isinstance(obj_or_model, model):\n            val = getattr(obj_or_model, aid)\n        elif obj_pk is None:\n            val = None\n        else:\n            val = model.objects.values_list(aid, flat=True).get(\n                pk=obj_pk,\n            )\n        if val:\n            return val\n\n    if obj_pk is None:\n        # bail out if args are (model, pk) but pk is None.\n        return None\n\n    # fallback to using AleaIdField from ObjectMapping model.\n    content_type = ContentType.objects.get_for_model(model)\n    try:\n        return ObjectMapping.objects.values_list(\n            'meteor_id', flat=True,\n        ).get(\n            content_type=content_type,\n            object_id=obj_pk,\n        )\n    except ObjectDoesNotExist:\n        return ObjectMapping.objects.create(\n            content_type=content_type,\n            object_id=obj_pk,\n            meteor_id=meteor_random_id('/collection/%s' % meta),\n        ).meteor_id", "language": "python", "code": "def get_meteor_id(obj_or_model, obj_pk=None):\n    \"\"\"Return an Alea ID for the given object.\"\"\"\n    if obj_or_model is None:\n        return None\n    # Django model._meta is now public API -> pylint: disable=W0212\n    meta = obj_or_model._meta\n    model = meta.model\n    if model is ObjectMapping:\n        # this doesn't make sense - raise TypeError\n        raise TypeError(\"Can't map ObjectMapping instances through self.\")\n\n    # try getting value of AleaIdField straight from instance if possible\n    if isinstance(obj_or_model, model):\n        # obj_or_model is an instance, not a model.\n        if isinstance(meta.pk, AleaIdField):\n            return obj_or_model.pk\n        if obj_pk is None:\n            # fall back to primary key, but coerce as string type for lookup.\n            obj_pk = str(obj_or_model.pk)\n    alea_unique_fields = [\n        field\n        for field in meta.local_fields\n        if isinstance(field, AleaIdField) and field.unique\n    ]\n    if len(alea_unique_fields) == 1:\n        # found an AleaIdField with unique=True, assume it's got the value.\n        aid = alea_unique_fields[0].attname\n        if isinstance(obj_or_model, model):\n            val = getattr(obj_or_model, aid)\n        elif obj_pk is None:\n            val = None\n        else:\n            val = model.objects.values_list(aid, flat=True).get(\n                pk=obj_pk,\n            )\n        if val:\n            return val\n\n    if obj_pk is None:\n        # bail out if args are (model, pk) but pk is None.\n        return None\n\n    # fallback to using AleaIdField from ObjectMapping model.\n    content_type = ContentType.objects.get_for_model(model)\n    try:\n        return ObjectMapping.objects.values_list(\n            'meteor_id', flat=True,\n        ).get(\n            content_type=content_type,\n            object_id=obj_pk,\n        )\n    except ObjectDoesNotExist:\n        return ObjectMapping.objects.create(\n            content_type=content_type,\n            object_id=obj_pk,\n            meteor_id=meteor_random_id('/collection/%s' % meta),\n        ).meteor_id", "code_tokens": ["def", "get_meteor_id", "(", "obj_or_model", ",", "obj_pk", "=", "None", ")", ":", "if", "obj_or_model", "is", "None", ":", "return", "None", "# Django model._meta is now public API -> pylint: disable=W0212", "meta", "=", "obj_or_model", ".", "_meta", "model", "=", "meta", ".", "model", "if", "model", "is", "ObjectMapping", ":", "# this doesn't make sense - raise TypeError", "raise", "TypeError", "(", "\"Can't map ObjectMapping instances through self.\"", ")", "# try getting value of AleaIdField straight from instance if possible", "if", "isinstance", "(", "obj_or_model", ",", "model", ")", ":", "# obj_or_model is an instance, not a model.", "if", "isinstance", "(", "meta", ".", "pk", ",", "AleaIdField", ")", ":", "return", "obj_or_model", ".", "pk", "if", "obj_pk", "is", "None", ":", "# fall back to primary key, but coerce as string type for lookup.", "obj_pk", "=", "str", "(", "obj_or_model", ".", "pk", ")", "alea_unique_fields", "=", "[", "field", "for", "field", "in", "meta", ".", "local_fields", "if", "isinstance", "(", "field", ",", "AleaIdField", ")", "and", "field", ".", "unique", "]", "if", "len", "(", "alea_unique_fields", ")", "==", "1", ":", "# found an AleaIdField with unique=True, assume it's got the value.", "aid", "=", "alea_unique_fields", "[", "0", "]", ".", "attname", "if", "isinstance", "(", "obj_or_model", ",", "model", ")", ":", "val", "=", "getattr", "(", "obj_or_model", ",", "aid", ")", "elif", "obj_pk", "is", "None", ":", "val", "=", "None", "else", ":", "val", "=", "model", ".", "objects", ".", "values_list", "(", "aid", ",", "flat", "=", "True", ")", ".", "get", "(", "pk", "=", "obj_pk", ",", ")", "if", "val", ":", "return", "val", "if", "obj_pk", "is", "None", ":", "# bail out if args are (model, pk) but pk is None.", "return", "None", "# fallback to using AleaIdField from ObjectMapping model.", "content_type", "=", "ContentType", ".", "objects", ".", "get_for_model", "(", "model", ")", "try", ":", "return", "ObjectMapping", ".", "objects", ".", "values_list", "(", "'meteor_id'", ",", "flat", "=", "True", ",", ")", ".", "get", "(", "content_type", "=", "content_type", ",", "object_id", "=", "obj_pk", ",", ")", "except", "ObjectDoesNotExist", ":", "return", "ObjectMapping", ".", "objects", ".", "create", "(", "content_type", "=", "content_type", ",", "object_id", "=", "obj_pk", ",", "meteor_id", "=", "meteor_random_id", "(", "'/collection/%s'", "%", "meta", ")", ",", ")", ".", "meteor_id"], "docstring": "Return an Alea ID for the given object.", "docstring_tokens": ["Return", "an", "Alea", "ID", "for", "the", "given", "object", "."], "sha": "1e1954b06fe140346acea43582515991685e4e01", "url": "https://github.com/jazzband/django-ddp/blob/1e1954b06fe140346acea43582515991685e4e01/dddp/models.py#L20-L76", "partition": "test", "cyclomatic_complexity": 15}, {"repo": "nats-io/asyncio-nats", "path": "nats/aio/client.py", "func_name": "Client.subscribe", "original_string": "def subscribe(self, subject,\n                  queue=\"\",\n                  cb=None,\n                  future=None,\n                  max_msgs=0,\n                  is_async=False,\n                  pending_msgs_limit=DEFAULT_SUB_PENDING_MSGS_LIMIT,\n                  pending_bytes_limit=DEFAULT_SUB_PENDING_BYTES_LIMIT,\n                  ):\n        \"\"\"\n        Takes a subject string and optional queue string to send a SUB cmd,\n        and a callback which to which messages (Msg) will be dispatched to\n        be processed sequentially by default.\n        \"\"\"\n        if subject == \"\":\n            raise ErrBadSubject\n\n        if self.is_closed:\n            raise ErrConnectionClosed\n\n        if self.is_draining:\n            raise ErrConnectionDraining\n\n        sub = Subscription(subject=subject,\n                           queue=queue,\n                           max_msgs=max_msgs,\n                           is_async=is_async,\n                           )\n        if cb is not None:\n            if asyncio.iscoroutinefunction(cb):\n                sub.coro = cb\n            elif sub.is_async:\n                raise NatsError(\n                    \"nats: must use coroutine for async subscriptions\")\n            else:\n                # NOTE: Consider to deprecate this eventually, it should always\n                # be coroutines otherwise they could affect the single thread,\n                # for now still allow to be flexible.\n                sub.cb = cb\n\n            sub.pending_msgs_limit = pending_msgs_limit\n            sub.pending_bytes_limit = pending_bytes_limit\n            sub.pending_queue = asyncio.Queue(\n                maxsize=pending_msgs_limit,\n                loop=self._loop,\n                )\n\n            # Close the delivery coroutine over the sub and error handler\n            # instead of having subscription type hold over state of the conn.\n            err_cb = self._error_cb\n\n            @asyncio.coroutine\n            def wait_for_msgs():\n                nonlocal sub\n                nonlocal err_cb\n\n                while True:\n                    try:\n                        msg = yield from sub.pending_queue.get()\n                        sub.pending_size -= len(msg.data)\n\n                        try:\n                            # Invoke depending of type of handler.\n                            if sub.coro is not None:\n                                if sub.is_async:\n                                    # NOTE: Deprecate this usage in a next release,\n                                    # the handler implementation ought to decide\n                                    # the concurrency level at which the messages\n                                    # should be processed.\n                                    self._loop.create_task(sub.coro(msg))\n                                else:\n                                    yield from sub.coro(msg)\n                            elif sub.cb is not None:\n                                if sub.is_async:\n                                    raise NatsError(\n                                        \"nats: must use coroutine for async subscriptions\")\n                                else:\n                                    # Schedule regular callbacks to be processed sequentially.\n                                    self._loop.call_soon(sub.cb, msg)\n                        except asyncio.CancelledError:\n                            # In case the coroutine handler gets cancelled\n                            # then stop task loop and return.\n                            break\n                        except Exception as e:\n                            # All errors from calling a handler\n                            # are async errors.\n                            if err_cb is not None:\n                                yield from err_cb(e)\n\n                    except asyncio.CancelledError:\n                        break\n\n            # Start task for each subscription, it should be cancelled\n            # on both unsubscribe and closing as well.\n            sub.wait_for_msgs_task = self._loop.create_task(\n                wait_for_msgs())\n\n        elif future is not None:\n            # Used to handle the single response from a request.\n            sub.future = future\n        else:\n            raise NatsError(\"nats: invalid subscription type\")\n\n        self._ssid += 1\n        ssid = self._ssid\n        self._subs[ssid] = sub\n        yield from self._subscribe(sub, ssid)\n        return ssid", "language": "python", "code": "def subscribe(self, subject,\n                  queue=\"\",\n                  cb=None,\n                  future=None,\n                  max_msgs=0,\n                  is_async=False,\n                  pending_msgs_limit=DEFAULT_SUB_PENDING_MSGS_LIMIT,\n                  pending_bytes_limit=DEFAULT_SUB_PENDING_BYTES_LIMIT,\n                  ):\n        \"\"\"\n        Takes a subject string and optional queue string to send a SUB cmd,\n        and a callback which to which messages (Msg) will be dispatched to\n        be processed sequentially by default.\n        \"\"\"\n        if subject == \"\":\n            raise ErrBadSubject\n\n        if self.is_closed:\n            raise ErrConnectionClosed\n\n        if self.is_draining:\n            raise ErrConnectionDraining\n\n        sub = Subscription(subject=subject,\n                           queue=queue,\n                           max_msgs=max_msgs,\n                           is_async=is_async,\n                           )\n        if cb is not None:\n            if asyncio.iscoroutinefunction(cb):\n                sub.coro = cb\n            elif sub.is_async:\n                raise NatsError(\n                    \"nats: must use coroutine for async subscriptions\")\n            else:\n                # NOTE: Consider to deprecate this eventually, it should always\n                # be coroutines otherwise they could affect the single thread,\n                # for now still allow to be flexible.\n                sub.cb = cb\n\n            sub.pending_msgs_limit = pending_msgs_limit\n            sub.pending_bytes_limit = pending_bytes_limit\n            sub.pending_queue = asyncio.Queue(\n                maxsize=pending_msgs_limit,\n                loop=self._loop,\n                )\n\n            # Close the delivery coroutine over the sub and error handler\n            # instead of having subscription type hold over state of the conn.\n            err_cb = self._error_cb\n\n            @asyncio.coroutine\n            def wait_for_msgs():\n                nonlocal sub\n                nonlocal err_cb\n\n                while True:\n                    try:\n                        msg = yield from sub.pending_queue.get()\n                        sub.pending_size -= len(msg.data)\n\n                        try:\n                            # Invoke depending of type of handler.\n                            if sub.coro is not None:\n                                if sub.is_async:\n                                    # NOTE: Deprecate this usage in a next release,\n                                    # the handler implementation ought to decide\n                                    # the concurrency level at which the messages\n                                    # should be processed.\n                                    self._loop.create_task(sub.coro(msg))\n                                else:\n                                    yield from sub.coro(msg)\n                            elif sub.cb is not None:\n                                if sub.is_async:\n                                    raise NatsError(\n                                        \"nats: must use coroutine for async subscriptions\")\n                                else:\n                                    # Schedule regular callbacks to be processed sequentially.\n                                    self._loop.call_soon(sub.cb, msg)\n                        except asyncio.CancelledError:\n                            # In case the coroutine handler gets cancelled\n                            # then stop task loop and return.\n                            break\n                        except Exception as e:\n                            # All errors from calling a handler\n                            # are async errors.\n                            if err_cb is not None:\n                                yield from err_cb(e)\n\n                    except asyncio.CancelledError:\n                        break\n\n            # Start task for each subscription, it should be cancelled\n            # on both unsubscribe and closing as well.\n            sub.wait_for_msgs_task = self._loop.create_task(\n                wait_for_msgs())\n\n        elif future is not None:\n            # Used to handle the single response from a request.\n            sub.future = future\n        else:\n            raise NatsError(\"nats: invalid subscription type\")\n\n        self._ssid += 1\n        ssid = self._ssid\n        self._subs[ssid] = sub\n        yield from self._subscribe(sub, ssid)\n        return ssid", "code_tokens": ["def", "subscribe", "(", "self", ",", "subject", ",", "queue", "=", "\"\"", ",", "cb", "=", "None", ",", "future", "=", "None", ",", "max_msgs", "=", "0", ",", "is_async", "=", "False", ",", "pending_msgs_limit", "=", "DEFAULT_SUB_PENDING_MSGS_LIMIT", ",", "pending_bytes_limit", "=", "DEFAULT_SUB_PENDING_BYTES_LIMIT", ",", ")", ":", "if", "subject", "==", "\"\"", ":", "raise", "ErrBadSubject", "if", "self", ".", "is_closed", ":", "raise", "ErrConnectionClosed", "if", "self", ".", "is_draining", ":", "raise", "ErrConnectionDraining", "sub", "=", "Subscription", "(", "subject", "=", "subject", ",", "queue", "=", "queue", ",", "max_msgs", "=", "max_msgs", ",", "is_async", "=", "is_async", ",", ")", "if", "cb", "is", "not", "None", ":", "if", "asyncio", ".", "iscoroutinefunction", "(", "cb", ")", ":", "sub", ".", "coro", "=", "cb", "elif", "sub", ".", "is_async", ":", "raise", "NatsError", "(", "\"nats: must use coroutine for async subscriptions\"", ")", "else", ":", "# NOTE: Consider to deprecate this eventually, it should always", "# be coroutines otherwise they could affect the single thread,", "# for now still allow to be flexible.", "sub", ".", "cb", "=", "cb", "sub", ".", "pending_msgs_limit", "=", "pending_msgs_limit", "sub", ".", "pending_bytes_limit", "=", "pending_bytes_limit", "sub", ".", "pending_queue", "=", "asyncio", ".", "Queue", "(", "maxsize", "=", "pending_msgs_limit", ",", "loop", "=", "self", ".", "_loop", ",", ")", "# Close the delivery coroutine over the sub and error handler", "# instead of having subscription type hold over state of the conn.", "err_cb", "=", "self", ".", "_error_cb", "@", "asyncio", ".", "coroutine", "def", "wait_for_msgs", "(", ")", ":", "nonlocal", "sub", "nonlocal", "err_cb", "while", "True", ":", "try", ":", "msg", "=", "yield", "from", "sub", ".", "pending_queue", ".", "get", "(", ")", "sub", ".", "pending_size", "-=", "len", "(", "msg", ".", "data", ")", "try", ":", "# Invoke depending of type of handler.", "if", "sub", ".", "coro", "is", "not", "None", ":", "if", "sub", ".", "is_async", ":", "# NOTE: Deprecate this usage in a next release,", "# the handler implementation ought to decide", "# the concurrency level at which the messages", "# should be processed.", "self", ".", "_loop", ".", "create_task", "(", "sub", ".", "coro", "(", "msg", ")", ")", "else", ":", "yield", "from", "sub", ".", "coro", "(", "msg", ")", "elif", "sub", ".", "cb", "is", "not", "None", ":", "if", "sub", ".", "is_async", ":", "raise", "NatsError", "(", "\"nats: must use coroutine for async subscriptions\"", ")", "else", ":", "# Schedule regular callbacks to be processed sequentially.", "self", ".", "_loop", ".", "call_soon", "(", "sub", ".", "cb", ",", "msg", ")", "except", "asyncio", ".", "CancelledError", ":", "# In case the coroutine handler gets cancelled", "# then stop task loop and return.", "break", "except", "Exception", "as", "e", ":", "# All errors from calling a handler", "# are async errors.", "if", "err_cb", "is", "not", "None", ":", "yield", "from", "err_cb", "(", "e", ")", "except", "asyncio", ".", "CancelledError", ":", "break", "# Start task for each subscription, it should be cancelled", "# on both unsubscribe and closing as well.", "sub", ".", "wait_for_msgs_task", "=", "self", ".", "_loop", ".", "create_task", "(", "wait_for_msgs", "(", ")", ")", "elif", "future", "is", "not", "None", ":", "# Used to handle the single response from a request.", "sub", ".", "future", "=", "future", "else", ":", "raise", "NatsError", "(", "\"nats: invalid subscription type\"", ")", "self", ".", "_ssid", "+=", "1", "ssid", "=", "self", ".", "_ssid", "self", ".", "_subs", "[", "ssid", "]", "=", "sub", "yield", "from", "self", ".", "_subscribe", "(", "sub", ",", "ssid", ")", "return", "ssid"], "docstring": "Takes a subject string and optional queue string to send a SUB cmd,\n        and a callback which to which messages (Msg) will be dispatched to\n        be processed sequentially by default.", "docstring_tokens": ["Takes", "a", "subject", "string", "and", "optional", "queue", "string", "to", "send", "a", "SUB", "cmd", "and", "a", "callback", "which", "to", "which", "messages", "(", "Msg", ")", "will", "be", "dispatched", "to", "be", "processed", "sequentially", "by", "default", "."], "sha": "39e840be0b12ce326edac0bba69aeb1be930dcb8", "url": "https://github.com/nats-io/asyncio-nats/blob/39e840be0b12ce326edac0bba69aeb1be930dcb8/nats/aio/client.py#L478-L585", "partition": "test", "cyclomatic_complexity": 10}]}